<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pok√©mon Battle Simulator V3</title>
    <style>
      :root {
        /* Color Palette (iOS Inspired) */
        --primary-color: #007aff; /* Blue */
        --secondary-color: #6c757d; /* Gray */
        --success-color: #34c759; /* Green */
        --warning-color: #ffcc00; /* Yellow */
        --danger-color: #ff3b30; /* Red */
        --info-color: #5ac8fa; /* Teal */
        --light-gray: #f2f2f7;
        --medium-gray: #e5e5ea;
        --dark-gray: #1c1c1e;
        --text-light: #ffffff;
        --text-dark: #1d1d1f;

        /* Fonts */
        --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        --font-mono: "SF Mono", "Consolas", "Monaco", "Courier New", monospace;

        /* Type Colors */
        --type-normal: #a8a77a;
        --type-normal-text: white;
        --type-fire: #f57d31;
        --type-fire-text: white;
        --type-water: #6390f0;
        --type-water-text: white;
        --type-electric: #f7d02c;
        --type-electric-text: var(--text-dark);
        --type-grass: #7ac74c;
        --type-grass-text: white;
        --type-ice: #96d9d6;
        --type-ice-text: var(--text-dark);
        --type-fighting: #c22e28;
        --type-fighting-text: white;
        --type-poison: #a33ea1;
        --type-poison-text: white;
        --type-ground: #e2bf65;
        --type-ground-text: var(--text-dark);
        --type-flying: #a98ff3;
        --type-flying-text: white;
        --type-psychic: #f95587;
        --type-psychic-text: white;
        --type-bug: #a6b91a;
        --type-bug-text: white;
        --type-rock: #b6a136;
        --type-rock-text: white;
        --type-ghost: #735797;
        --type-ghost-text: white;
        --type-dragon: #6f35fc;
        --type-dragon-text: white;
        --type-dark: #705746;
        --type-dark-text: white;
        --type-steel: #b7b7ce;
        --type-steel-text: var(--text-dark);
        --type-fairy: #d685ad;
        --type-fairy-text: white;
        --type-status: #8a8a8d;
        --type-status-text: white;

        /* Status Colors */
        --status-par-bg: var(--warning-color);
        --status-par-text: var(--text-dark);
        --status-brn-bg: var(--danger-color);
        --status-brn-text: white;
        --status-psn-bg: var(--type-poison);
        --status-psn-text: white;
        --status-slp-bg: var(--secondary-color);
        --status-slp-text: white;
        --status-frz-bg: var(--info-color);
        --status-frz-text: var(--text-dark);
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html {
        font-size: 16px;
      }

      body {
        font-family: var(--font-sans);
        background-color: var(--light-gray);
        background-image: linear-gradient(
            45deg,
            rgba(0, 0, 0, 0.02) 25%,
            transparent 25%,
            transparent 75%,
            rgba(0, 0, 0, 0.02) 75%,
            rgba(0, 0, 0, 0.02)
          ),
          linear-gradient(
            45deg,
            rgba(0, 0, 0, 0.02) 25%,
            transparent 25%,
            transparent 75%,
            rgba(0, 0, 0, 0.02) 75%,
            rgba(0, 0, 0, 0.02)
          );
        background-size: 60px 60px;
        background-position: 0 0, 30px 30px;
        margin: 0;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: var(--text-dark);
        line-height: 1.6;
        min-height: 100vh;
        overflow-x: hidden; /* Prevent horizontal scroll during animations */
      }

      .battle-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 700px; /* Slightly wider */
        gap: 1rem;
      }

      .battlefield {
        background: rgba(255, 255, 255, 0.95); /* More opaque */
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px); /* Safari */
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 28px; /* Even more rounded */
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.12),
          0 5px 15px rgba(0, 0, 0, 0.08);
        width: 100%;
        padding: 1.5rem 2rem; /* More padding */
        position: relative;
        overflow: hidden;
        transition: transform 0.3s ease-out; /* For screen shake */
      }
      .battlefield.shake {
        animation: screen-shake 0.3s linear;
      }
      @keyframes screen-shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-4px);
        }
        50% {
          transform: translateX(4px);
        }
        75% {
          transform: translateX(-4px);
        }
      }

      .side {
        display: flex;
        align-items: flex-end;
        gap: 1rem;
        margin-bottom: 3rem; /* Increased space between sides */
        min-height: 120px; /* Taller */
        position: relative;
      }
      .side:last-child {
        margin-bottom: 0;
      }

      .left {
        justify-content: flex-start;
      }
      .right {
        justify-content: flex-end;
        text-align: right;
      }

      .avatar-container {
        width: 120px; /* Larger avatar */
        height: 120px;
        position: relative;
        flex-shrink: 0; /* Prevent shrinking */
        transform: translateY(100%);
        opacity: 0;
        transition: transform 0.7s cubic-bezier(0.25, 1, 0.5, 1),
          opacity 0.6s ease-out;
      }
      .avatar-container.enter {
        transform: translateY(0);
        opacity: 1;
      }

      .avatar {
        width: 100%;
        height: 100%;
        background: var(--medium-gray);
        border-radius: 16px; /* More rounded */
        border: 4px solid transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        image-rendering: pixelated; /* Keep pixel art sharp */
        image-rendering: crisp-edges; /* Better compatibility */
        transition: transform 0.3s ease-out, filter 0.5s ease-out,
          border-color 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      .avatar img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        transition: transform 0.15s ease-in-out, opacity 0.5s ease-out;
        opacity: 0; /* Start hidden, fade in via JS */
      }
      .avatar.placeholder {
        border: 4px dashed #a0a0a5;
        background: var(--light-gray);
      }

      /* Active/Idle state */
      .active .avatar {
        animation: active-bounce 1.3s infinite ease-in-out;
      }
      @keyframes active-bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-4px) scale(1.02);
        }
      }

      /* Stat Change Indicator */
      .stat-change-indicator {
        position: absolute;
        top: -12px; /* Slightly higher */
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.8rem; /* Larger */
        font-weight: bold;
        opacity: 0;
        animation: stat-float 1.3s ease-out forwards; /* Longer duration */
        z-index: 5;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }
      .stat-up {
        color: var(--success-color);
      }
      .stat-down {
        color: var(--danger-color);
      }

      @keyframes stat-float {
        0% {
          opacity: 1;
          transform: translate(-50%, 10px) scale(0.8);
        }
        20% {
          transform: translate(-50%, -15px) scale(1.1);
        } /* Bounce up */
        100% {
          opacity: 0;
          transform: translate(-50%, -40px) scale(0.6);
        } /* Fade out higher */
      }

      /* Hit animation */
      .hit .avatar img {
        animation: hit-shake 0.3s linear;
      }
      .opponent.hit .avatar img {
        animation: hit-shake-opponent 0.3s linear;
      } /* Use specific class for opponent */
      @keyframes hit-shake {
        /* Player (sprite faces right, needs scaleX(-1)) */
        0%,
        100% {
          transform: translateX(0) scaleX(-1);
        }
        25%,
        75% {
          transform: translateX(-7px) scaleX(-1);
        }
        50% {
          transform: translateX(7px) scaleX(-1);
        }
      }
      @keyframes hit-shake-opponent {
        /* Opponent (sprite faces left) */
        0%,
        100% {
          transform: translateX(0);
        }
        25%,
        75% {
          transform: translateX(7px);
        } /* Opposite direction shake */
        50% {
          transform: translateX(-7px);
        }
      }

      /* Faint animation */
      .fainted .avatar-container {
        animation: faint-fall 1.1s cubic-bezier(0.6, -0.28, 0.735, 0.045)
          forwards;
      } /* EaseInBack */
      .fainted .avatar img {
        filter: grayscale(1) opacity(0.4);
        transition: filter 0.9s ease-out;
      }
      @keyframes faint-fall {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(70px) rotate(-20deg);
          opacity: 0;
        }
      }

      .info {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 1rem;
        flex-grow: 1;
        padding-bottom: 8px;
        position: relative; /* For stat indicator positioning */
      }
      /* Position stat indicator relative to info box instead of name */
      .info .stat-change-indicator {
        top: -15px; /* Adjust position relative to info box top */
        left: 50%;
      }
      .right .info .stat-change-indicator {
        left: 50%; /* Keep centered */
      }

      .name-status {
        display: flex;
        align-items: center;
        gap: 0.7rem;
        margin-bottom: 0.3rem;
        /* position: relative; Remove relative positioning here */
      }
      .right .name-status {
        justify-content: flex-end;
      }

      .name {
        font-weight: 700; /* Bolder */
        font-size: 1.4rem;
      }

      .status-badge {
        font-size: 0.8rem;
        font-weight: bold;
        padding: 0.2rem 0.6rem;
        border-radius: 8px;
        text-transform: uppercase;
        color: var(--text-light);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
        transition: opacity 0.4s ease, transform 0.4s ease;
        opacity: 1;
        transform: scale(1);
      }
      .status-badge.hidden {
        opacity: 0;
        transform: scale(0.7);
        pointer-events: none;
      }
      .status-PAR {
        background-color: var(--status-par-bg);
        color: var(--status-par-text);
      }
      .status-BRN {
        background-color: var(--status-brn-bg);
        color: var(--status-brn-text);
      }
      .status-PSN {
        background-color: var(--status-psn-bg);
        color: var(--status-psn-text);
      }
      .status-SLP {
        background-color: var(--status-slp-bg);
        color: var(--status-slp-text);
      }
      .status-FRZ {
        background-color: var(--status-frz-bg);
        color: var(--status-frz-text);
      }

      .level {
        font-size: 0.9rem;
        color: var(--secondary-color);
      }

      .hp-bar {
        background: var(--medium-gray);
        border-radius: 999px;
        overflow: hidden;
        height: 16px; /* Thicker */
        width: 100%;
        max-width: 240px; /* Max width */
        border: 1px solid #bbb; /* Slightly darker border */
        position: relative;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.15);
      }
      .right .hp-bar {
        margin-left: auto;
      }

      .hp-fill {
        background: var(--success-color);
        height: 100%;
        transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1),
          background-color 0.5s ease-out;
        border-radius: 999px;
        position: relative;
      }
      .hp-bar::before {
        content: "HP";
        position: absolute;
        left: 8px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 10px;
        font-weight: bold;
        color: rgba(0, 0, 0, 0.7);
        line-height: 1;
        z-index: 1;
      }

      .hp-text {
        font-size: 0.9rem;
        color: var(--secondary-color);
        font-weight: 600;
        margin-top: 0.3rem;
      }
      .right .hp-text {
        text-align: right;
      }

      .console {
        background: var(--dark-gray);
        border-radius: 16px;
        color: var(--text-light);
        padding: 1.25rem;
        font-family: var(--font-mono);
        font-size: 0.95rem;
        min-height: 150px;
        max-height: 350px;
        overflow-y: auto;
        line-height: 1.6;
        width: 100%;
        box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.4);
        border: 1px solid #444;
        scrollbar-width: thin;
        scrollbar-color: var(--primary-color) #3a3a3c;
        scroll-behavior: smooth; /* Smooth scrolling */
      }
      .console::-webkit-scrollbar {
        width: 8px;
      }
      .console::-webkit-scrollbar-track {
        background: #3a3a3c;
        border-radius: 4px;
      }
      .console::-webkit-scrollbar-thumb {
        background-color: var(--primary-color);
        border-radius: 4px;
        border: 2px solid #3a3a3c;
      }

      .console > div {
        padding-bottom: 0.4rem;
        margin-bottom: 0.4rem;
        border-bottom: 1px solid #4a4a4c; /* Lighter separator */
        transition: background-color 0.5s ease;
      }
      .console > div:last-child {
        border-bottom: none;
      }
      .console > div.highlight {
        background-color: rgba(255, 255, 255, 0.1);
      }

      .console .effectiveness {
        font-style: italic;
        color: #a0a0a5;
      }
      .console .critical {
        font-weight: bold;
        color: var(--warning-color);
        animation: pulse-yellow 0.8s ease-in-out;
      }
      .console .status-change {
        color: var(--info-color);
        font-style: italic;
      }
      .console .stat-change {
        color: #b0b0b0;
        font-style: italic;
      }
      .console .turn-divider {
        text-align: center;
        font-weight: bold;
        color: var(--info-color);
        margin: 1rem 0;
        padding-bottom: 1rem;
        letter-spacing: 1.5px;
        border-color: var(--info-color) !important;
      }
      .console .game-over {
        text-align: center;
        font-weight: bold;
        font-size: 1.2rem;
        margin-top: 1.2rem;
        color: var(--success-color);
        animation: pulse-green 1s infinite;
      }
      .console .player-prompt {
        font-weight: bold;
        color: var(--primary-color);
      }
      .console .player-choice {
        color: #87cefa;
      } /* LightSkyBlue */
      .console .opponent-choice {
        color: #ff7f7f;
      } /* LightCoral */
      .console .immune {
        font-style: italic;
        color: var(--secondary-color);
      }

      @keyframes pulse-yellow {
        0%,
        100% {
          text-shadow: 0 0 5px var(--warning-color);
        }
        50% {
          text-shadow: 0 0 15px var(--warning-color);
        }
      }
      @keyframes pulse-green {
        0%,
        100% {
          text-shadow: 0 0 5px var(--success-color);
        }
        50% {
          text-shadow: 0 0 15px var(--success-color);
        }
      }

      .attack-icon {
        position: absolute;
        font-size: 45px; /* Even larger */
        pointer-events: none;
        z-index: 10;
        opacity: 1;
        transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275),
          opacity 0.8s ease-out; /* EaseOutBack */
        text-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        will-change: transform, opacity; /* Performance hint */
      }

      /* Player Controls */
      .player-controls {
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px); /* Safari */
        border: 1px solid rgba(0, 0, 0, 0.07);
        border-radius: 20px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        padding: 1.25rem;
        width: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 1rem;
        transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        position: relative;
        will-change: opacity, transform; /* Performance hint */
      }
      .player-controls.hidden {
        opacity: 0;
        transform: translateY(40px);
        pointer-events: none;
      }

      .move-button {
        padding: 0.8rem 1.1rem;
        font-size: 1rem;
        font-weight: 600;
        border: none;
        border-radius: 14px;
        background-color: var(--medium-gray);
        color: var(--text-dark);
        cursor: pointer;
        text-align: center;
        transition: all 0.25s ease;
        position: relative;
        overflow: hidden;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.08);
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      .move-button:hover:not(:disabled) {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.12);
        transform: translateY(-3px);
        filter: brightness(1.05); /* Slight brighten */
      }

      .move-button:active:not(:disabled) {
        transform: scale(0.95) translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        filter: brightness(0.95); /* Slight darken */
      }

      .move-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        background-color: var(--medium-gray) !important; /* Ensure override */
        box-shadow: none;
        color: var(--secondary-color) !important; /* Ensure override */
        filter: grayscale(50%);
      }
      .move-button:disabled .move-pp {
        color: var(--secondary-color) !important;
      }

      .move-pp {
        font-size: 0.75rem;
        color: rgba(0, 0, 0, 0.55);
        display: block;
        margin-top: 4px;
        font-weight: 500;
      }

      /* Type-specific button styling (using CSS variables for text color) */
      .move-button[data-type="Normal"] {
        background-color: var(--type-normal);
        color: var(--type-normal-text);
        --button-text-color: var(--type-normal-text);
      }
      .move-button[data-type="Fire"] {
        background-color: var(--type-fire);
        color: var(--type-fire-text);
        --button-text-color: var(--type-fire-text);
      }
      .move-button[data-type="Water"] {
        background-color: var(--type-water);
        color: var(--type-water-text);
        --button-text-color: var(--type-water-text);
      }
      .move-button[data-type="Electric"] {
        background-color: var(--type-electric);
        color: var(--type-electric-text);
        --button-text-color: var(--type-electric-text);
      }
      .move-button[data-type="Grass"] {
        background-color: var(--type-grass);
        color: var(--type-grass-text);
        --button-text-color: var(--type-grass-text);
      }
      .move-button[data-type="Ice"] {
        background-color: var(--type-ice);
        color: var(--type-ice-text);
        --button-text-color: var(--type-ice-text);
      }
      .move-button[data-type="Fighting"] {
        background-color: var(--type-fighting);
        color: var(--type-fighting-text);
        --button-text-color: var(--type-fighting-text);
      }
      .move-button[data-type="Poison"] {
        background-color: var(--type-poison);
        color: var(--type-poison-text);
        --button-text-color: var(--type-poison-text);
      }
      .move-button[data-type="Ground"] {
        background-color: var(--type-ground);
        color: var(--type-ground-text);
        --button-text-color: var(--type-ground-text);
      }
      .move-button[data-type="Flying"] {
        background-color: var(--type-flying);
        color: var(--type-flying-text);
        --button-text-color: var(--type-flying-text);
      }
      .move-button[data-type="Psychic"] {
        background-color: var(--type-psychic);
        color: var(--type-psychic-text);
        --button-text-color: var(--type-psychic-text);
      }
      .move-button[data-type="Bug"] {
        background-color: var(--type-bug);
        color: var(--type-bug-text);
        --button-text-color: var(--type-bug-text);
      }
      .move-button[data-type="Rock"] {
        background-color: var(--type-rock);
        color: var(--type-rock-text);
        --button-text-color: var(--type-rock-text);
      }
      .move-button[data-type="Ghost"] {
        background-color: var(--type-ghost);
        color: var(--type-ghost-text);
        --button-text-color: var(--type-ghost-text);
      }
      .move-button[data-type="Dragon"] {
        background-color: var(--type-dragon);
        color: var(--type-dragon-text);
        --button-text-color: var(--type-dragon-text);
      }
      .move-button[data-type="Dark"] {
        background-color: var(--type-dark);
        color: var(--type-dark-text);
        --button-text-color: var(--type-dark-text);
      }
      .move-button[data-type="Steel"] {
        background-color: var(--type-steel);
        color: var(--type-steel-text);
        --button-text-color: var(--type-steel-text);
      }
      .move-button[data-type="Fairy"] {
        background-color: var(--type-fairy);
        color: var(--type-fairy-text);
        --button-text-color: var(--type-fairy-text);
      }
      .move-button[data-category="Status"] {
        background-color: var(--type-status);
        color: var(--type-status-text);
        --button-text-color: var(--type-status-text);
      }

      /* Use text color variable for PP */
      .move-button[data-type] .move-pp,
      .move-button[data-category="Status"] .move-pp {
        color: color-mix(
          in srgb,
          var(--button-text-color, black) 65%,
          transparent
        );
      }

      .restart-button {
        margin-top: 1.5rem;
        padding: 0.9rem 1.8rem;
        font-size: 1.1rem;
        font-weight: 600;
        border: none;
        border-radius: 14px;
        background-color: var(--primary-color);
        color: white;
        cursor: pointer;
        transition: all 0.25s ease;
        box-shadow: 0 5px 12px rgba(0, 122, 255, 0.35);
        display: inline-block; /* Allow margin top */
      }
      .restart-button:hover {
        background-color: #005fcc; /* Darker blue */
        box-shadow: 0 7px 15px rgba(0, 122, 255, 0.45);
        transform: translateY(-2px);
      }
      .restart-button:active {
        background-color: #004080;
        transform: translateY(0);
        box-shadow: 0 3px 7px rgba(0, 122, 255, 0.25);
      }
      .restart-button.hidden {
        display: none;
      }

      /* Media Query for smaller screens */
      @media (max-width: 640px) {
        body {
          padding: 0.5rem;
        }
        .battle-container {
          gap: 0.75rem;
        }
        .battlefield {
          padding: 1rem 1.25rem;
          border-radius: 20px;
        }
        .side {
          margin-bottom: 2rem;
          gap: 0.75rem;
          min-height: 100px;
        }
        .avatar-container {
          width: 100px;
          height: 100px;
        }
        .avatar {
          border-radius: 12px;
          border-width: 3px;
        }
        .info {
          gap: 0.3rem;
          padding-bottom: 5px;
        }
        .name {
          font-size: 1.2rem;
        }
        .level {
          font-size: 0.8rem;
        }
        .hp-bar {
          height: 14px;
          max-width: 190px;
          border-width: 1px;
        }
        .hp-bar::before {
          font-size: 9px;
          left: 6px;
        }
        .hp-text {
          font-size: 0.8rem;
        }
        .console {
          min-height: 120px;
          max-height: 250px;
          font-size: 0.85rem;
          padding: 1rem;
          border-radius: 12px;
        }
        .player-controls {
          padding: 1rem;
          gap: 0.75rem;
          grid-template-columns: repeat(2, 1fr);
          border-radius: 16px;
        }
        .move-button {
          padding: 0.7rem 0.9rem;
          font-size: 0.9rem;
          border-radius: 12px;
        }
        .move-pp {
          font-size: 0.7rem;
        }
        .attack-icon {
          font-size: 35px;
        }
        .restart-button {
          padding: 0.8rem 1.5rem;
          font-size: 1rem;
          margin-top: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="battle-container">
      <div class="battlefield" id="battlefield">
        <!-- Opponent Side -->
        <div class="side right opponent" id="opponent-side">
          <div class="info">
            <div class="name-status">
              <span class="status-badge hidden" id="pokemon1-status"></span>
              <div class="name" id="pokemon1-name">Opponent</div>
            </div>
            <div class="level" id="pokemon1-level">Lv. ?</div>
            <div class="hp-bar">
              <div class="hp-fill" id="pokemon1-hp"></div>
            </div>
            <div class="hp-text" id="pokemon1-hp-text">? / ? HP</div>
          </div>
          <div class="avatar-container" id="pokemon1-avatar-container">
            <div class="avatar placeholder" id="pokemon1-avatar"></div>
          </div>
        </div>

        <!-- Player Side -->
        <div class="side left player" id="player-side">
          <div class="avatar-container" id="pokemon2-avatar-container">
            <div class="avatar placeholder" id="pokemon2-avatar"></div>
          </div>
          <div class="info">
            <div class="name-status">
              <div class="name" id="pokemon2-name">Player</div>
              <span class="status-badge hidden" id="pokemon2-status"></span>
            </div>
            <div class="level" id="pokemon2-level">Lv. ?</div>
            <div class="hp-bar">
              <div class="hp-fill" id="pokemon2-hp"></div>
            </div>
            <div class="hp-text" id="pokemon2-hp-text">? / ? HP</div>
          </div>
        </div>
      </div>

      <div class="console" id="console">Initializing Battle Environment...</div>

      <div class="player-controls hidden" id="player-controls">
        <!-- Move buttons will be generated here -->
      </div>

      <button id="restart-button" class="restart-button hidden">
        Battle Again!
      </button>
    </div>

    <script>
      // ********* MODULE: GLOBAL STATE & CONSTANTS **************
      const BATTLE_STATE = {
        playerPokemon: null,
        opponentPokemon: null,
        isPlayerTurn: false,
        waitingForPlayer: false,
        gameOver: false,
        playerMoveResolver: null, // Promise resolver for player input
        turnCounter: 0,
        battleLog: [], // Keep track of log messages if needed later
        isProcessing: false, // Flag to prevent multiple actions during animations/processing
      };

      const STATUS_EFFECTS = {
        PAR: {
          name: "PAR",
          badgeText: "PAR",
          cssClass: "status-PAR",
          turnStartEffect: true,
        },
        BRN: {
          name: "BRN",
          badgeText: "BRN",
          cssClass: "status-BRN",
          turnEndEffect: true,
        },
        PSN: {
          name: "PSN",
          badgeText: "PSN",
          cssClass: "status-PSN",
          turnEndEffect: true,
        },
        SLP: {
          name: "SLP",
          badgeText: "SLP",
          cssClass: "status-SLP",
          turnStartEffect: true,
        }, // Counter handled in Pokemon class
        FRZ: {
          name: "FRZ",
          badgeText: "FRZ",
          cssClass: "status-FRZ",
          turnStartEffect: true,
        },
      };

      const ANIMATION_DELAY = {
        SHORT: 400,
        MEDIUM: 700,
        LONG: 900,
        HP_BAR: 600,
        ATTACK_ICON: 800,
        FAINT: 1100,
        TURN_TRANSITION: 600,
        STATUS_EFFECT: 800,
        STAT_CHANGE: 1300, // Increased to match new animation duration
        ENTRY: 700, // Corresponds to avatar-container transition
      };

      // Accuracy/Evasion Stages (Simplified: Multiplier applied to move accuracy)
      const ACC_EVA_MULTIPLIERS = {
        "-6": 3 / 9,
        "-5": 3 / 8,
        "-4": 3 / 7,
        "-3": 3 / 6,
        "-2": 3 / 5,
        "-1": 3 / 4,
        0: 1,
        1: 4 / 3,
        2: 5 / 3,
        3: 6 / 3,
        4: 7 / 3,
        5: 8 / 3,
        6: 9 / 3,
      };
      // Stat Stage Multipliers (Atk, Def, SpA, SpD, Spe)
      const STAT_STAGE_MULTIPLIERS = {
        "-6": 2 / 8,
        "-5": 2 / 7,
        "-4": 2 / 6,
        "-3": 2 / 5,
        "-2": 2 / 4,
        "-1": 2 / 3,
        0: 1,
        1: 3 / 2,
        2: 4 / 2,
        3: 5 / 2,
        4: 6 / 2,
        5: 7 / 2,
        6: 8 / 2,
      };

      // Simplified Type Chart (Gen VI+)
      const TYPE_CHART = {
        Normal: { Rock: 0.5, Ghost: 0, Steel: 0.5 },
        Fire: {
          Fire: 0.5,
          Water: 0.5,
          Grass: 2,
          Ice: 2,
          Bug: 2,
          Rock: 0.5,
          Dragon: 0.5,
          Steel: 2,
        },
        Water: {
          Fire: 2,
          Water: 0.5,
          Grass: 0.5,
          Ground: 2,
          Rock: 2,
          Dragon: 0.5,
        },
        Electric: {
          Water: 2,
          Electric: 0.5,
          Grass: 0.5,
          Ground: 0,
          Flying: 2,
          Dragon: 0.5,
        },
        Grass: {
          Fire: 0.5,
          Water: 2,
          Grass: 0.5,
          Poison: 0.5,
          Ground: 2,
          Flying: 0.5,
          Bug: 0.5,
          Rock: 2,
          Dragon: 0.5,
          Steel: 0.5,
        },
        Ice: {
          Fire: 0.5,
          Water: 0.5,
          Grass: 2,
          Ice: 0.5,
          Ground: 2,
          Flying: 2,
          Dragon: 2,
          Steel: 0.5,
        },
        Fighting: {
          Normal: 2,
          Flying: 0.5,
          Poison: 0.5,
          Rock: 2,
          Bug: 0.5,
          Ghost: 0,
          Psychic: 0.5,
          Ice: 2,
          Dark: 2,
          Steel: 2,
          Fairy: 0.5,
        },
        Poison: {
          Grass: 2,
          Poison: 0.5,
          Ground: 0.5,
          Rock: 0.5,
          Ghost: 0.5,
          Steel: 0,
          Fairy: 2,
        },
        Ground: {
          Fire: 2,
          Electric: 2,
          Grass: 0.5,
          Poison: 2,
          Flying: 0,
          Bug: 0.5,
          Rock: 2,
          Steel: 2,
        },
        Flying: {
          Electric: 0.5,
          Grass: 2,
          Fighting: 2,
          Bug: 2,
          Rock: 0.5,
          Steel: 0.5,
        },
        Psychic: { Fighting: 2, Poison: 2, Psychic: 0.5, Dark: 0, Steel: 0.5 },
        Bug: {
          Fire: 0.5,
          Grass: 2,
          Fighting: 0.5,
          Poison: 0.5,
          Flying: 0.5,
          Psychic: 2,
          Ghost: 0.5,
          Dark: 2,
          Steel: 0.5,
          Fairy: 0.5,
        },
        Rock: {
          Fire: 2,
          Ice: 2,
          Fighting: 0.5,
          Ground: 0.5,
          Flying: 2,
          Bug: 2,
          Steel: 0.5,
        },
        Ghost: { Normal: 0, Psychic: 2, Ghost: 2, Dark: 0.5 },
        Dragon: { Dragon: 2, Steel: 0.5, Fairy: 0 },
        Dark: { Fighting: 0.5, Psychic: 2, Ghost: 2, Dark: 0.5, Fairy: 0.5 },
        Steel: {
          Normal: 1,
          Fire: 0.5,
          Water: 0.5,
          Electric: 0.5,
          Grass: 1,
          Ice: 2,
          Fighting: 1,
          Poison: 1,
          Ground: 1,
          Flying: 1,
          Psychic: 1,
          Bug: 1,
          Rock: 2,
          Ghost: 1,
          Dragon: 1,
          Dark: 1,
          Steel: 0.5,
          Fairy: 2,
        },
        Fairy: {
          Fire: 0.5,
          Fighting: 2,
          Poison: 0.5,
          Dragon: 2,
          Dark: 2,
          Steel: 0.5,
        },
      };

      const ATTACK_ICONS = {
        Fire: "üî•",
        Water: "üíß",
        Grass: "üåø",
        Electric: "‚ö°",
        Normal: "‚≠ê",
        Fighting: "‚úä",
        Psychic: "üåÄ",
        Ghost: "üëª",
        Rock: "üóø",
        Ground: "‚õ∞Ô∏è",
        Flying: "üïäÔ∏è",
        Bug: "üêû",
        Poison: "‚ò†Ô∏è",
        Ice: "‚ùÑÔ∏è",
        Dragon: "üêâ",
        Dark: "üåë",
        Steel: "üî©",
        Fairy: "‚ú®",
        Status: "üí´",
      };

      // Chance Constants
      const CRIT_CHANCE = 1 / 24;
      const PARALYSIS_CHANCE = 0.25; // Chance of being fully paralyzed
      const THAW_CHANCE = 0.2; // Chance of thawing from Freeze

      // ********* MODULE: POKEMON DATA & CLASS **************
      class Pokemon {
        constructor(name, level, types, stats, moves, sprite) {
          this.name = name;
          this.level = level;
          this.types = Array.isArray(types) ? types : [types]; // Ensure array
          this.baseStats = stats; // { hp, atk, def, spa, spd, spe }
          this.moves = moves.map((m) => ({ ...m, currentPP: m.pp }));
          this.sprite = sprite;
          this.id = Math.random().toString(36).substring(7); // Unique ID for tracking if needed
          this.reset();
        }

        reset() {
          // Use base stats provided, do not recalculate here, calculate during battle init
          this.currentStats = { ...this.baseStats }; // Store base stats for calculation
          this.level = this.level; // Keep original level

          this.maxHp = this.calculateStatValue(
            this.baseStats.hp,
            this.level,
            true
          );
          this.hp = this.maxHp;
          this.status = null;
          this.statusCounter = 0; // For SLP/PSN (toxic) turns primarily
          this.isFainted = false;
          this.statStages = {
            atk: 0,
            def: 0,
            spa: 0,
            spd: 0,
            spe: 0,
            accuracy: 0,
            evasion: 0,
          };
          this.moves.forEach((m) => (m.currentPP = m.pp)); // Reset PP
        }

        calculateStatValue(base, level, isHp = false) {
          // Simplified stat calculation (Gen 3+, ignoring IVs/EVs)
          if (isHp) {
            if (base === 1) return 1; // Shedinja case
            // Formula: floor(((Base * 2 + IV + floor(EV/4)) * Level) / 100) + Level + 10
            // Simplified: floor(((Base * 2) * Level) / 100) + Level + 10
            return Math.floor((base * 2 * level) / 100 + level + 10);
          } else {
            // Formula: floor( (floor(((Base * 2 + IV + floor(EV/4)) * Level) / 100) + 5) * Nature )
            // Simplified: floor(((Base * 2 * Level) / 100) + 5)
            return Math.floor((base * 2 * level) / 100 + 5);
          }
        }

        getModifiedStat(
          statName,
          ignorePositiveStages = false,
          ignoreNegativeStages = false
        ) {
          const baseStatValue = this.calculateStatValue(
            this.currentStats[statName],
            this.level
          );
          if (!baseStatValue) return 1; // Safety check

          let stage = this.statStages[statName];

          // Critical hits ignore positive Def/SpD stages of the defender
          if (
            (statName === "def" || statName === "spd") &&
            ignorePositiveStages &&
            stage > 0
          )
            stage = 0;
          // Critical hits ignore negative Atk/SpA stages of the attacker
          if (
            (statName === "atk" || statName === "spa") &&
            ignoreNegativeStages &&
            stage < 0
          )
            stage = 0;

          const multiplier = STAT_STAGE_MULTIPLIERS[stage] || 1.0;

          let finalStat = baseStatValue * multiplier;

          // Apply status conditions AFTER stages
          // Burn halves physical attack stat (critical hits ignore this via ignoreNegativeStages)
          if (
            statName === "atk" &&
            this.status === "BRN" &&
            !ignoreNegativeStages
          ) {
            finalStat *= 0.5;
          }
          // Paralysis halves speed stat (Gen 7+ effect)
          if (statName === "spe" && this.status === "PAR") {
            finalStat *= 0.5;
          }

          return Math.max(1, Math.floor(finalStat)); // Minimum stat value is 1
        }

        applyStatus(status, sourcePokemon = null) {
          if (this.status || this.isFainted) {
            if (this.status)
              log(
                `${this.name} is already afflicted with ${
                  STATUS_EFFECTS[this.status].badgeText
                }!`,
                "immune"
              );
            return false; // Already statused or fainted
          }

          // Type immunities
          if (status === "BRN" && this.types.includes("Fire")) return false;
          if (
            status === "PSN" &&
            (this.types.includes("Poison") || this.types.includes("Steel"))
          )
            return false;
          if (status === "PAR" && this.types.includes("Electric")) return false; // Ground immunity handled by move accuracy/typing check for electric moves
          if (status === "FRZ" && this.types.includes("Ice")) return false;
          // Add safeguard check later if implemented

          this.status = status;
          this.statusCounter = 0; // Reset counter on new status
          let statusMsg = `${this.name} was afflicted with ${STATUS_EFFECTS[status].badgeText}!`;

          if (status === "SLP") {
            this.statusCounter = Math.floor(Math.random() * 3) + 1; // Sleep for 1-3 turns (simplified)
            statusMsg = `${this.name} fell asleep!`;
          }
          log(statusMsg, "status-change");
          return true;
        }

        clearStatus() {
          if (this.status) {
            log(
              `${this.name} is no longer ${
                STATUS_EFFECTS[this.status].badgeText
              }.`,
              "status-change"
            );
            this.status = null;
            this.statusCounter = 0;
            return true;
          }
          return false;
        }

        changeStatStage(statName, change, showIndicator = true) {
          if (!this.statStages.hasOwnProperty(statName) || this.isFainted)
            return false;

          const currentStage = this.statStages[statName];
          const newStage = Math.max(-6, Math.min(6, currentStage + change));
          const actualChange = newStage - currentStage; // How much it actually changed

          if (actualChange === 0) {
            log(
              `${this.name}'s ${statName.toUpperCase()} won't go any ${
                change > 0 ? "higher" : "lower"
              }!`,
              "stat-change"
            );
            return false;
          } else {
            this.statStages[statName] = newStage;
            let changeText = "";
            if (Math.abs(actualChange) >= 2)
              changeText = `sharply ${change > 0 ? "rose" : "fell"}`;
            else changeText = `${change > 0 ? "rose" : "fell"}`;
            log(
              `${this.name}'s ${statName.toUpperCase()} ${changeText}!`,
              "stat-change"
            );

            // Trigger visual indicator
            if (showIndicator) {
              const targetSide =
                this === BATTLE_STATE.playerPokemon
                  ? "player-side"
                  : "opponent-side";
              showStatChangeIndicator(targetSide, actualChange > 0);
            }
            return true;
          }
        }

        heal(percent) {
          if (this.isFainted || this.hp >= this.maxHp) return false;
          const healAmount = Math.floor(this.maxHp * percent);
          const healedHp = Math.min(this.maxHp, this.hp + healAmount);
          const actualHeal = healedHp - this.hp;

          if (actualHeal <= 0) return false;

          this.hp = healedHp;
          log(`${this.name} recovered ${actualHeal} HP!`, "status-change"); // Using status-change style for heal
          return true;
        }
      }

      const MOVES = {
        // Physical
        Tackle: {
          name: "Tackle",
          type: "Normal",
          power: 40,
          accuracy: 1,
          pp: 35,
          category: "Physical",
          priority: 0,
        },
        Scratch: {
          name: "Scratch",
          type: "Normal",
          power: 40,
          accuracy: 1,
          pp: 35,
          category: "Physical",
          priority: 0,
        },
        QuickAttack: {
          name: "Quick Attack",
          type: "Normal",
          power: 40,
          accuracy: 1,
          pp: 30,
          category: "Physical",
          priority: 1,
        },
        PoisonSting: {
          name: "Poison Sting",
          type: "Poison",
          power: 15,
          accuracy: 1,
          pp: 35,
          category: "Physical",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "PSN",
            chance: 0.3,
          },
        },
        BodySlam: {
          name: "Body Slam",
          type: "Normal",
          power: 85,
          accuracy: 1,
          pp: 15,
          category: "Physical",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "PAR",
            chance: 0.3,
          },
        },
        // Special
        VineWhip: {
          name: "Vine Whip",
          type: "Grass",
          power: 45,
          accuracy: 1,
          pp: 25,
          category: "Special",
          priority: 0,
        },
        Ember: {
          name: "Ember",
          type: "Fire",
          power: 40,
          accuracy: 1,
          pp: 25,
          category: "Special",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "BRN",
            chance: 0.1,
          },
        },
        WaterGun: {
          name: "Water Gun",
          type: "Water",
          power: 40,
          accuracy: 1,
          pp: 25,
          category: "Special",
          priority: 0,
        },
        ThunderShock: {
          name: "Thunder Shock",
          type: "Electric",
          power: 40,
          accuracy: 1,
          pp: 30,
          category: "Special",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "PAR",
            chance: 0.1,
          },
        },
        IceBeam: {
          name: "Ice Beam",
          type: "Ice",
          power: 90,
          accuracy: 1,
          pp: 10,
          category: "Special",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "FRZ",
            chance: 0.1,
          },
        },
        Psychic: {
          name: "Psychic",
          type: "Psychic",
          power: 90,
          accuracy: 1,
          pp: 10,
          category: "Special",
          priority: 0,
          effect: {
            type: "lower_stat_chance",
            target: "opponent",
            stat: "spd",
            stages: -1,
            chance: 0.1,
          },
        },
        // Status
        Growl: {
          name: "Growl",
          type: "Normal",
          power: 0,
          accuracy: 1,
          pp: 40,
          category: "Status",
          priority: 0,
          effect: {
            type: "lower_stat",
            target: "opponent",
            stat: "atk",
            stages: -1,
          },
        },
        TailWhip: {
          name: "Tail Whip",
          type: "Normal",
          power: 0,
          accuracy: 1,
          pp: 30,
          category: "Status",
          priority: 0,
          effect: {
            type: "lower_stat",
            target: "opponent",
            stat: "def",
            stages: -1,
          },
        },
        ThunderWave: {
          name: "Thunder Wave",
          type: "Electric",
          power: 0,
          accuracy: 0.9,
          pp: 20,
          category: "Status",
          priority: 0,
          effect: { type: "apply_status", target: "opponent", status: "PAR" },
        },
        WillOWisp: {
          name: "Will-O-Wisp",
          type: "Fire",
          power: 0,
          accuracy: 0.85,
          pp: 15,
          category: "Status",
          priority: 0,
          effect: { type: "apply_status", target: "opponent", status: "BRN" },
        },
        SleepPowder: {
          name: "Sleep Powder",
          type: "Grass",
          power: 0,
          accuracy: 0.75,
          pp: 15,
          category: "Status",
          priority: 0,
          effect: { type: "apply_status", target: "opponent", status: "SLP" },
        },
        SwordsDance: {
          name: "Swords Dance",
          type: "Normal",
          power: 0,
          accuracy: null,
          pp: 20,
          category: "Status",
          priority: 0,
          effect: {
            type: "raise_stat",
            target: "self",
            stat: "atk",
            stages: 2,
          },
        }, // Accuracy null = always hits self
        Recover: {
          name: "Recover",
          type: "Normal",
          power: 0,
          accuracy: null,
          pp: 10,
          category: "Status",
          priority: 0,
          effect: { type: "heal_percent", target: "self", amount: 0.5 },
        }, // Heal 50% max HP
        // Struggle
        Struggle: {
          name: "Struggle",
          type: "Normal",
          power: 50,
          accuracy: null,
          pp: Infinity,
          category: "Physical",
          priority: 0,
          effect: { type: "recoil_user_maxhp_percent", amount: 0.25 },
          ignoresTypeImmunity: true,
          isStruggle: true,
        },
      };

      const POKEMON_DATA = {
        Bulbasaur: {
          name: "Bulbasaur",
          level: 5,
          types: ["Grass", "Poison"],
          stats: { hp: 45, atk: 49, def: 49, spa: 65, spd: 65, spe: 45 },
          moves: [MOVES.Tackle, MOVES.VineWhip, MOVES.Growl, MOVES.SleepPowder],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png",
        },
        Charmander: {
          name: "Charmander",
          level: 5,
          types: ["Fire"],
          stats: { hp: 39, atk: 52, def: 43, spa: 60, spd: 50, spe: 65 },
          moves: [MOVES.Scratch, MOVES.Ember, MOVES.Growl, MOVES.WillOWisp],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/4.png",
        },
        Squirtle: {
          name: "Squirtle",
          level: 5,
          types: ["Water"],
          stats: { hp: 44, atk: 48, def: 65, spa: 50, spd: 64, spe: 43 },
          moves: [MOVES.Tackle, MOVES.WaterGun, MOVES.TailWhip, MOVES.Recover],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/7.png",
        },
        Pikachu: {
          name: "Pikachu",
          level: 6,
          types: ["Electric"],
          stats: { hp: 35, atk: 55, def: 40, spa: 50, spd: 50, spe: 90 },
          moves: [
            MOVES.ThunderShock,
            MOVES.QuickAttack,
            MOVES.TailWhip,
            MOVES.ThunderWave,
          ],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png",
        },
        Staryu: {
          name: "Staryu",
          level: 5,
          types: ["Water"],
          stats: { hp: 30, atk: 45, def: 55, spa: 70, spd: 55, spe: 85 },
          moves: [MOVES.WaterGun, MOVES.Recover, MOVES.IceBeam, MOVES.Psychic],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/120.png",
        },
        Meowth: {
          name: "Meowth",
          level: 5,
          types: ["Normal"],
          stats: { hp: 40, atk: 45, def: 35, spa: 40, spd: 40, spe: 90 },
          moves: [
            MOVES.Scratch,
            MOVES.Growl,
            MOVES.QuickAttack,
            MOVES.BodySlam,
          ],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/52.png",
        },
      };

      function clonePokemon(baseData) {
        // Create a new Pokemon instance, letting the constructor handle setup
        return new Pokemon(
          baseData.name,
          baseData.level,
          [...baseData.types], // Deep copy types array
          { ...baseData.stats }, // Shallow copy base stats object (values are numbers)
          baseData.moves.map((m) => ({ ...m })), // Deep copy moves array and each move object
          baseData.sprite
        );
      }

      // ********* MODULE: BATTLE LOGIC **************

      function calculateTypeEffectiveness(
        moveType,
        targetTypes,
        ignoreImmunity = false
      ) {
        let multiplier = 1;
        if (!moveType || moveType === "Status") return 1; // Status moves don't use this directly

        targetTypes.forEach((targetType) => {
          const effectivenessMap = TYPE_CHART[moveType];
          if (effectivenessMap && effectivenessMap[targetType] !== undefined) {
            multiplier *= effectivenessMap[targetType];
          }
          // Check specific hardcoded immunities only if not ignoring them
          if (!ignoreImmunity) {
            if (multiplier === 0) return; // Already immune from type chart
            if (moveType === "Ground" && targetType === "Flying")
              multiplier = 0;
            if (moveType === "Electric" && targetType === "Ground")
              multiplier = 0;
            if (moveType === "Psychic" && targetType === "Dark") multiplier = 0;
            if (moveType === "Poison" && targetType === "Steel") multiplier = 0;
            if (moveType === "Dragon" && targetType === "Fairy") multiplier = 0;
            if (moveType === "Normal" && targetType === "Ghost") multiplier = 0;
            if (moveType === "Fighting" && targetType === "Ghost")
              multiplier = 0;
            // Ghost immunity handled by TYPE_CHART
          }
        });

        return multiplier;
      }

      function calculateAccuracy(attacker, move, defender) {
        // Null or undefined accuracy means it always hits (e.g., status moves on self, Swift)
        if (move.accuracy === null || move.accuracy === undefined) return true;
        // Accuracy 1 or higher should generally hit, but stages can affect it
        if (
          move.accuracy >= 1 &&
          attacker.statStages.accuracy <= 0 &&
          defender.statStages.evasion >= 0
        )
          return true;

        const baseAccuracy = move.accuracy;
        // Apply stages clamp between -6 and +6
        const attackerAccStage = Math.max(
          -6,
          Math.min(6, attacker.statStages.accuracy)
        );
        const defenderEvaStage = Math.max(
          -6,
          Math.min(6, defender.statStages.evasion)
        );

        const accMultiplier = ACC_EVA_MULTIPLIERS[attackerAccStage];
        const evaMultiplier = ACC_EVA_MULTIPLIERS[-defenderEvaStage]; // Use inverted evasion stage

        const finalAccuracy = baseAccuracy * accMultiplier * evaMultiplier;

        // Add check for status modifiers (e.g., Paralysis accuracy drop - not implemented here)

        return Math.random() < finalAccuracy;
      }

      function calculateDamage(attacker, move, defender) {
        if (move.power <= 0 || move.category === "Status")
          return { damage: 0, effectiveness: 1, crit: false, recoilDamage: 0 };

        const isCritical = Math.random() < CRIT_CHANCE;
        const critMultiplier = isCritical ? 1.5 : 1; // Gen 6+ crit multiplier

        // Critical hits ignore attacker's negative Atk/SpA stages & Burn, and defender's positive Def/SpD stages
        const ignoreNegativeAtk = isCritical;
        const ignorePositiveDef = isCritical;

        let attackStatValue, defenseStatValue;

        if (move.category === "Physical") {
          attackStatValue = attacker.getModifiedStat(
            "atk",
            false,
            ignoreNegativeAtk
          );
          defenseStatValue = defender.getModifiedStat(
            "def",
            ignorePositiveDef,
            false
          );
        } else if (move.category === "Special") {
          attackStatValue = attacker.getModifiedStat(
            "spa",
            false,
            ignoreNegativeAtk
          );
          defenseStatValue = defender.getModifiedStat(
            "spd",
            ignorePositiveDef,
            false
          );
        } else {
          return { damage: 0, effectiveness: 1, crit: false, recoilDamage: 0 }; // Should not happen
        }

        // Base Damage Calculation (Simplified Gen V+ formula component)
        let damage =
          (((2 * attacker.level) / 5 + 2) *
            move.power *
            (attackStatValue / defenseStatValue)) /
            50 +
          2;

        // Modifiers
        const isSTAB = attacker.types.includes(move.type);
        const stabMultiplier = isSTAB ? 1.5 : 1;
        const typeEffectiveness = calculateTypeEffectiveness(
          move.type,
          defender.types,
          move.ignoresTypeImmunity
        );
        const randomVariance = Math.random() * (1.0 - 0.85) + 0.85; // 85% - 100% variance
        // Burn penalty applied via getModifiedStat

        damage *= stabMultiplier;
        damage *= typeEffectiveness;
        damage *= critMultiplier;
        damage *= randomVariance;

        // Ensure damage is at least 1 if it hits and isn't immune, otherwise 0
        damage = typeEffectiveness === 0 || damage < 1 ? 0 : Math.floor(damage);
        // Make sure damage is at least 1 if effectiveness > 0
        if (typeEffectiveness > 0 && damage === 0) damage = 1;

        // Calculate recoil damage
        let recoilDamage = 0;
        if (move.effect?.type === "recoil_damage_percent" && damage > 0) {
          // Recoil based on damage dealt
          recoilDamage = Math.max(
            1,
            Math.floor(damage * (move.effect.amount || 0))
          );
        } else if (move.effect?.type === "recoil_user_maxhp_percent") {
          // Recoil based on user's max HP (Struggle)
          recoilDamage = Math.max(
            1,
            Math.floor(attacker.maxHp * (move.effect.amount || 0))
          );
        }

        return {
          damage: Math.floor(damage),
          effectiveness: typeEffectiveness,
          crit: isCritical,
          recoilDamage: recoilDamage,
        };
      }

      // ********* MODULE: UI & ANIMATION **************

      function log(msg, type = "") {
        const consolePanel = document.getElementById("console");
        if (!consolePanel) return;
        const logEntry = document.createElement("div");
        logEntry.innerHTML = msg; // Use innerHTML for simple formatting (bold, etc.)
        if (type) {
          logEntry.classList.add(type);
        }
        consolePanel.appendChild(logEntry);
        BATTLE_STATE.battleLog.push({ msg, type });

        // Highlight the new entry briefly
        logEntry.classList.add("highlight");
        setTimeout(() => logEntry.classList.remove("highlight"), 800);

        // Auto-scroll smoothly
        consolePanel.scrollTop = consolePanel.scrollHeight;

        // Log plain text to browser console for debugging
        console.log(msg.replace(/<[^>]*>/g, ""));
      }

      function updateHPDisplay(pokemon, elPrefix) {
        const fill = document.getElementById(`${elPrefix}-hp`);
        const hpText = document.getElementById(`${elPrefix}-hp-text`);
        const sideContainer = document.getElementById(
          elPrefix === "pokemon1" ? "opponent-side" : "player-side"
        );
        const statusBadge = document.getElementById(`${elPrefix}-status`);

        if (!fill || !hpText || !sideContainer || !statusBadge) return; // Safety check

        const currentHp = Math.max(0, pokemon.hp);
        const percent = (currentHp / pokemon.maxHp) * 100;
        fill.style.width = percent + "%";

        // HP Bar Color Transitions
        if (percent < 20) fill.style.backgroundColor = "var(--danger-color)";
        else if (percent < 50)
          fill.style.backgroundColor = "var(--warning-color)";
        else fill.style.backgroundColor = "var(--success-color)";

        hpText.textContent = `${currentHp} / ${pokemon.maxHp} HP`;

        // Update Status Badge
        statusBadge.className = "status-badge hidden"; // Reset classes
        if (pokemon.status && STATUS_EFFECTS[pokemon.status]) {
          const statusInfo = STATUS_EFFECTS[pokemon.status];
          statusBadge.textContent = statusInfo.badgeText;
          statusBadge.classList.add(statusInfo.cssClass);
          statusBadge.classList.remove("hidden");
        }

        // Update fainted visual state
        if (pokemon.isFainted) {
          sideContainer.classList.add("fainted");
          sideContainer.classList.remove("active"); // Ensure not active if fainted
          statusBadge.classList.add("hidden"); // Hide status on faint
        } else {
          sideContainer.classList.remove("fainted");
        }
      }

      async function playFaintAnimation(pokemonId) {
        const sideContainer = document.getElementById(
          pokemonId === "pokemon1" ? "opponent-side" : "player-side"
        );
        if (sideContainer) {
          sideContainer.classList.add("fainted");
          sideContainer.classList.remove("active");
          await delay(ANIMATION_DELAY.FAINT);
        }
      }

      function animateAttack(attackerElId, defenderElId, moveType) {
        const battlefield = document.querySelector(".battlefield");
        const attackerAvatar = document.getElementById(attackerElId);
        const defenderAvatar = document.getElementById(defenderElId);

        if (!attackerAvatar || !defenderAvatar || !battlefield) return;

        const attackerSide = attackerAvatar.closest(".side");
        const defenderSide = defenderAvatar.closest(".side");

        const attRect = attackerAvatar.getBoundingClientRect();
        const defRect = defenderAvatar.getBoundingClientRect();
        const bfRect = battlefield.getBoundingClientRect();

        const icon = document.createElement("div");
        icon.className = "attack-icon";
        icon.textContent = ATTACK_ICONS[moveType] || ATTACK_ICONS["Status"];
        battlefield.appendChild(icon);

        // Start near the center of the attacker
        const startX = attRect.left + attRect.width / 2 - bfRect.left;
        const startY = attRect.top + attRect.height / 2 - bfRect.top;
        icon.style.left = `${startX}px`;
        icon.style.top = `${startY}px`;
        icon.style.transform = "translate(-50%, -50%) scale(0.6)"; // Center icon and start smaller
        icon.style.opacity = "1";

        // Target the center of the defender
        const endX = defRect.left + defRect.width / 2 - bfRect.left;
        const endY = defRect.top + defRect.height / 2 - bfRect.top;

        // Trigger animation using requestAnimationFrame for smoother start
        requestAnimationFrame(() => {
          icon.style.transform = `translate(${
            endX - startX - icon.offsetWidth / 2
          }px, ${endY - startY - icon.offsetHeight / 2}px) scale(1)`;
          icon.style.opacity = "0";
        });

        // Add hit class to defender's side for visual feedback
        if (defenderSide) {
          defenderSide.classList.add("hit");
          setTimeout(
            () => defenderSide.classList.remove("hit"),
            ANIMATION_DELAY.SHORT
          );
        }

        // Remove icon after animation
        setTimeout(() => icon.remove(), ANIMATION_DELAY.ATTACK_ICON);
      }

      function showStatChangeIndicator(sideId, isIncrease) {
        const sideElement = document.getElementById(sideId);
        const infoElement = sideElement?.querySelector(".info"); // Attach to info box
        if (!infoElement) return;

        // Remove any existing indicator first
        const existingIndicator = infoElement.querySelector(
          ".stat-change-indicator"
        );
        if (existingIndicator) existingIndicator.remove();

        const indicator = document.createElement("div");
        indicator.className = `stat-change-indicator ${
          isIncrease ? "stat-up" : "stat-down"
        }`;
        indicator.textContent = isIncrease ? "‚ñ≤" : "‚ñº";

        infoElement.appendChild(indicator);

        // Remove after animation
        setTimeout(() => indicator.remove(), ANIMATION_DELAY.STAT_CHANGE); // Match animation duration
      }

      function triggerScreenShake() {
        const battlefield = document.getElementById("battlefield");
        battlefield.classList.add("shake");
        setTimeout(() => battlefield.classList.remove("shake"), 300); // Match animation duration
      }

      function updatePlayerControls(pokemon) {
        const controlsContainer = document.getElementById("player-controls");
        controlsContainer.innerHTML = ""; // Clear previous buttons

        if (
          BATTLE_STATE.gameOver ||
          !BATTLE_STATE.isPlayerTurn ||
          BATTLE_STATE.waitingForPlayer
        ) {
          controlsContainer.classList.add("hidden");
          return;
        }

        const usableMoves = pokemon.moves.filter((m) => m.currentPP > 0);
        // Show Struggle only if NO moves have PP left
        const movesToDisplay =
          usableMoves.length > 0
            ? usableMoves
            : [{ ...MOVES.Struggle, currentPP: Infinity }]; // Clone Struggle for display

        movesToDisplay.forEach((move) => {
          const button = document.createElement("button");
          button.classList.add("move-button");
          button.dataset.type = move.type;
          button.dataset.category = move.category;
          const currentPPLabel =
            move.pp === Infinity || move.isStruggle ? "--" : move.currentPP;
          const maxPPLabel =
            move.pp === Infinity || move.isStruggle ? "--" : move.pp;
          button.innerHTML = `
            ${move.name}
            <span class="move-pp">${currentPPLabel} / ${maxPPLabel} PP</span>
        `;
          // Disable check ensures Struggle is never disabled here
          button.disabled = move.currentPP <= 0 && !move.isStruggle;

          button.onclick = () => {
            if (
              BATTLE_STATE.waitingForPlayer &&
              BATTLE_STATE.playerMoveResolver &&
              !button.disabled &&
              !BATTLE_STATE.isProcessing
            ) {
              BATTLE_STATE.waitingForPlayer = false; // Input received
              controlsContainer.classList.add("hidden"); // Hide controls immediately
              // Find the actual move object from the pokemon's moveset, or use Struggle if needed
              const chosenMove =
                pokemon.moves.find((m) => m.name === move.name) ||
                MOVES.Struggle;
              BATTLE_STATE.playerMoveResolver(chosenMove); // Resolve the promise
            }
          };
          controlsContainer.appendChild(button);
        });

        controlsContainer.classList.remove("hidden");
        BATTLE_STATE.waitingForPlayer = true; // Ready for input
        log("Choose your move!", "player-prompt"); // Prompt player
      }

      // ********* MODULE: AI LOGIC **************

      function chooseOpponentMove(attacker, defender) {
        const usableMoves = attacker.moves.filter((m) => m.currentPP > 0);
        if (usableMoves.length === 0) return MOVES.Struggle;

        let potentialMoves = [];

        usableMoves.forEach((move) => {
          let score = 0;
          const moveEffect = move.effect || {};

          // --- Pre-checks for Viability ---
          let isViable = true;

          // Check type immunity for damaging moves
          if (move.category !== "Status") {
            const effectiveness = calculateTypeEffectiveness(
              move.type,
              defender.types
            );
            if (effectiveness === 0) isViable = false;
          }
          // Check specific immunities/conditions for status moves
          else if (move.category === "Status") {
            if (moveEffect.type?.includes("apply_status")) {
              const status = moveEffect.status;
              if (defender.status) isViable = false; // Already statused
              if (status === "BRN" && defender.types.includes("Fire"))
                isViable = false;
              if (
                status === "PSN" &&
                (defender.types.includes("Poison") ||
                  defender.types.includes("Steel"))
              )
                isViable = false;
              if (status === "PAR" && defender.types.includes("Electric"))
                isViable = false;
              if (status === "FRZ" && defender.types.includes("Ice"))
                isViable = false;
              if (move.type === "Electric" && defender.types.includes("Ground"))
                isViable = false; // e.g., Thunder Wave vs Ground
              if (
                defender.types.includes("Grass") &&
                move.name === "Sleep Powder"
              )
                isViable = false; // Grass immune to powders
            } else if (moveEffect.type === "lower_stat") {
              if (defender.statStages[moveEffect.stat] <= -6) isViable = false; // Cannot lower further
            } else if (moveEffect.type === "raise_stat") {
              if (attacker.statStages[moveEffect.stat] >= 6) isViable = false; // Cannot raise further
            } else if (moveEffect.type === "heal_percent") {
              if (attacker.hp >= attacker.maxHp) isViable = false; // Cannot heal if full HP
            }
          }

          // If not viable, give very low score and skip detailed scoring
          if (!isViable) {
            potentialMoves.push({ move, score: -100 + Math.random() }); // Add random noise to break ties among bad choices
            return;
          }

          // --- Scoring Logic for Viable Moves ---
          if (move.category === "Physical" || move.category === "Special") {
            const { damage, effectiveness } = calculateDamage(
              attacker,
              move,
              defender
            ); // Use calc for estimate
            score = (move.power || 10) * effectiveness; // Base score on power * effectiveness (use 10 for 0 power edge cases)

            if (effectiveness > 1) score *= 1.8; // Strong bonus for super effective
            if (effectiveness < 1) score *= 0.4; // Penalty for not very effective

            // Check for potential KO (use a margin for random variance)
            const estimatedDamageHigh = damage * (1 / 0.85); // Estimate max possible damage
            if (defender.hp > 0 && defender.hp <= estimatedDamageHigh) {
              score *= 3; // Highly prioritize potential KOs
            }
          } else if (move.category === "Status") {
            // Apply Status
            if (moveEffect.type?.includes("apply_status")) {
              score = 45; // Good score for applying status
              if (moveEffect.status === "SLP" || moveEffect.status === "FRZ")
                score += 15; // Higher value for sleep/freeze
            }
            // Lower Stat
            else if (moveEffect.type === "lower_stat") {
              score = 30 + Math.abs(moveEffect.stages * 10); // Value based on stage drops
              if (defender.statStages[moveEffect.stat] < -2) score *= 0.5; // Less valuable if already debuffed
            }
            // Raise Stat
            else if (moveEffect.type === "raise_stat") {
              score = 25 + moveEffect.stages * 10; // Base value
              // Prioritize boosting main attacking stat or speed
              if (
                moveEffect.stat === "atk" ||
                moveEffect.stat === "spa" ||
                moveEffect.stat === "spe"
              ) {
                score += 15;
              }
              if (attacker.statStages[moveEffect.stat] > 2) score *= 0.5; // Less valuable if already buffed
            }
            // Heal
            else if (moveEffect.type === "heal_percent") {
              // More value the lower the HP
              score = 55 + (1 - attacker.hp / attacker.maxHp) * 50;
              if (attacker.hp > attacker.maxHp * 0.7) score *= 0.3; // Less valuable if HP is high
            }
          }

          // Add slight penalty for low accuracy moves
          if (move.accuracy < 1 && move.accuracy !== null) {
            score *= 0.7 + move.accuracy * 0.3;
          }

          // Add small randomness to break ties
          score += Math.random() * 5;

          potentialMoves.push({ move, score });
        });

        // Filter out the truly non-viable moves unless they are the only option
        const viableMoves = potentialMoves.filter((pm) => pm.score > -50);

        if (viableMoves.length > 0) {
          viableMoves.sort((a, b) => b.score - a.score);
          // console.log("AI Choices:", viableMoves.map(m => ({ name: m.move.name, score: m.score.toFixed(1) }))); // Debug AI choices
          return viableMoves[0].move; // Choose the best viable move
        } else if (potentialMoves.length > 0) {
          // Fallback if all moves were heavily penalized (e.g., only immune moves left) - pick the least bad one
          potentialMoves.sort((a, b) => b.score - a.score);
          return potentialMoves[0].move;
        } else {
          // Should only happen if usableMoves was empty initially, safety fallback
          return MOVES.Struggle;
        }
      }

      // ********* MODULE: TURN & BATTLE FLOW **************

      async function delay(ms) {
        // Utility to pause execution without blocking the main thread
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function handleStatusEffectsAtTurnStart(pokemon, pokemonId) {
        if (pokemon.isFainted || !pokemon.status) return { canMove: true }; // Continue turn

        const status = pokemon.status;
        let canMove = true;
        let message = "";
        let clearedStatus = false;

        if (status === "PAR") {
          message = `${pokemon.name} is paralyzed!`;
          if (Math.random() < PARALYSIS_CHANCE) {
            message += ` It may be unable to move!`; // Changed message slightly
            log(message); // Log initial paralysis message
            await delay(ANIMATION_DELAY.STATUS_EFFECT / 2);
            log(`It couldn't move!`); // Separate message for clarity
            canMove = false;
            message = ""; // Clear message to avoid double logging
          }
        } else if (status === "SLP") {
          if (pokemon.statusCounter > 0) {
            message = `${pokemon.name} is fast asleep...`;
            pokemon.statusCounter--;
            canMove = false;
          } else {
            message = `${pokemon.name} woke up!`;
            pokemon.clearStatus(); // clearStatus logs its own message
            clearedStatus = true; // Flag used below
            updateHPDisplay(pokemon, pokemonId); // Update badge immediately
            message = ""; // Clear message as clearStatus handles it
          }
        } else if (status === "FRZ") {
          message = `${pokemon.name} is frozen solid!`;
          if (Math.random() < THAW_CHANCE) {
            // Use constant
            message = `${pokemon.name} thawed out!`;
            pokemon.clearStatus();
            clearedStatus = true;
            updateHPDisplay(pokemon, pokemonId); // Update badge immediately
            message = ""; // Clear message as clearStatus handles it
          } else {
            canMove = false;
          }
        }

        if (message) {
          // Log only if message wasn't cleared
          log(message, clearedStatus ? "status-change" : "");
          await delay(ANIMATION_DELAY.STATUS_EFFECT);
        }

        return { canMove };
      }

      async function handleStatusEffectsAtTurnEnd(pokemon, pokemonId) {
        if (pokemon.isFainted || !pokemon.status)
          return { faintedFromStatus: false };

        const status = pokemon.status;
        let faintedFromStatus = false;
        let statusDamage = 0;
        let message = "";

        if (status === "BRN") {
          statusDamage = Math.max(1, Math.floor(pokemon.maxHp / 16)); // Gen 7+ burn damage (1/16)
          message = `${pokemon.name} was hurt by its burn!`;
        } else if (status === "PSN") {
          statusDamage = Math.max(1, Math.floor(pokemon.maxHp / 8)); // Standard poison damage (1/8)
          message = `${pokemon.name} was hurt by poison!`;
        }
        // Add Badly Poisoned (Toxic) logic here later if needed (damage increases each turn)

        if (statusDamage > 0) {
          log(message, "status-change");
          await delay(ANIMATION_DELAY.STATUS_EFFECT / 2); // Short pause after message
          pokemon.hp -= statusDamage;
          updateHPDisplay(pokemon, pokemonId);
          triggerScreenShake(); // Shake screen slightly for status damage
          await delay(ANIMATION_DELAY.HP_BAR + ANIMATION_DELAY.SHORT); // Wait for HP bar visually + buffer

          if (pokemon.hp <= 0) {
            log(`<b>${pokemon.name} fainted!</b>`);
            pokemon.isFainted = true;
            faintedFromStatus = true;
            await playFaintAnimation(pokemonId);
          }
        }

        return { faintedFromStatus }; // Return true if fainted
      }

      async function executeMove(
        attacker,
        defender,
        move,
        attackerId,
        defenderId
      ) {
        const attackerAvatarElId = attackerId + "-avatar";
        const defenderAvatarElId = defenderId + "-avatar";

        // --- Use Move ---
        log(
          `<b>${attacker.name}</b> used <b>${move.name}</b>!`,
          attackerId === "pokemon2" ? "player-choice" : "opponent-choice"
        );
        if (move.pp !== Infinity && !move.isStruggle) {
          const moveInSet = attacker.moves.find((m) => m.name === move.name);
          if (moveInSet) moveInSet.currentPP--; // Decrement PP on the actual move object
        }
        // Update player controls immediately if it was their turn to reflect PP change
        // (This happens async, controls are hidden, but keeps data accurate for next turn)
        if (attackerId === "pokemon2" && !move.isStruggle) {
          // The updatePlayerControls function will read the updated PP when called next turn
        }
        await delay(ANIMATION_DELAY.MEDIUM);

        // --- Accuracy Check ---
        let hitTarget = calculateAccuracy(attacker, move, defender);
        if (!hitTarget) {
          log(`${attacker.name}'s attack missed!`);
          await delay(ANIMATION_DELAY.SHORT);
          return { fainted: false }; // Move ends on miss
        }

        // --- Check Type/Status Immunities (Primary Check) ---
        let isImmune = false;
        let immuneMessage = `It doesn't affect ${defender.name}...`;

        if (move.category !== "Status") {
          // Damage Move Type Immunity
          const effectiveness = calculateTypeEffectiveness(
            move.type,
            defender.types,
            move.ignoresTypeImmunity
          );
          if (effectiveness === 0) {
            isImmune = true;
          }
        } else {
          // Status Move Specific Immunities
          const moveEffect = move.effect || {};
          if (moveEffect.type?.includes("apply_status")) {
            const statusToApply = moveEffect.status;
            if (defender.status) {
              isImmune = true;
              immuneMessage = `${defender.name} is already afflicted with a status condition!`;
            } else if (
              statusToApply === "BRN" &&
              defender.types.includes("Fire")
            )
              isImmune = true;
            else if (
              statusToApply === "PSN" &&
              (defender.types.includes("Poison") ||
                defender.types.includes("Steel"))
            )
              isImmune = true;
            else if (
              statusToApply === "PAR" &&
              defender.types.includes("Electric")
            )
              isImmune = true;
            else if (statusToApply === "FRZ" && defender.types.includes("Ice"))
              isImmune = true;
            else if (
              move.type === "Electric" &&
              defender.types.includes("Ground")
            )
              isImmune = true;
            else if (
              defender.types.includes("Grass") &&
              move.name === "Sleep Powder"
            )
              isImmune = true;
          }
          // Add checks for other status effect immunities if needed (e.g. stat lowering vs Clear Body)
        }

        if (isImmune) {
          log(immuneMessage, "immune");
          await delay(ANIMATION_DELAY.SHORT);
          return { fainted: false }; // Move ends on immunity
        }

        // --- Execute Move Effects ---
        let defenderFaintedThisTurn = false;
        let attackerFaintedThisTurn = false;

        // Animate attack visual first
        animateAttack(
          attackerAvatarElId,
          defenderAvatarElId,
          move.type || move.category
        );
        await delay(ANIMATION_DELAY.SHORT); // Short pause during animation travel

        // --- Damage Calculation & Application ---
        if (move.category === "Physical" || move.category === "Special") {
          const { damage, effectiveness, crit, recoilDamage } = calculateDamage(
            attacker,
            move,
            defender
          );

          if (damage > 0) {
            defender.hp -= damage;
            updateHPDisplay(defender, defenderId); // Update HP bar
            // Trigger screen shake on hit, stronger on crit
            if (crit) triggerScreenShake();
            await delay(ANIMATION_DELAY.HP_BAR); // Wait for HP bar animation

            if (crit) {
              log("‚ú® <b>Critical Hit!</b> ‚ú®", "critical");
              await delay(ANIMATION_DELAY.SHORT);
            }
            if (effectiveness > 1)
              log("It's super effective!", "effectiveness");
            else if (effectiveness < 1)
              log("It's not very effective...", "effectiveness"); // Already checked effectiveness 0
            await delay(ANIMATION_DELAY.SHORT);

            if (defender.hp <= 0) {
              log(`<b>${defender.name} fainted!</b>`);
              defender.isFainted = true;
              defenderFaintedThisTurn = true;
              await playFaintAnimation(defenderId);
              // No need for further effects/recoil if target fainted
              return { fainted: true };
            }

            // Apply Recoil Damage (only if defender didn't faint)
            if (!defenderFaintedThisTurn && recoilDamage > 0) {
              log(`${attacker.name} took recoil damage!`);
              attacker.hp -= recoilDamage;
              updateHPDisplay(attacker, attackerId);
              triggerScreenShake(); // Also shake slightly for recoil
              await delay(ANIMATION_DELAY.HP_BAR + ANIMATION_DELAY.SHORT);
              if (attacker.hp <= 0) {
                log(`<b>${attacker.name} fainted from recoil!</b>`);
                attacker.isFainted = true;
                attackerFaintedThisTurn = true;
                await playFaintAnimation(attackerId);
                // Attacker fainted, turn ends for them
                return { fainted: true };
              }
            }
          } else {
            // Damage was 0, but not due to immunity (e.g. vs protect, or just 0 damage calc)
            log("The attack had no effect."); // Or maybe "But it failed!" if vs Protect later
            await delay(ANIMATION_DELAY.SHORT);
          }
        } // End Damage Phase

        // --- Apply Move Secondary Effects (Status, Stat Changes, Heal) ---
        // Only apply if defender didn't faint from the primary hit and attacker didn't faint from recoil
        if (
          !defenderFaintedThisTurn &&
          !attackerFaintedThisTurn &&
          move.effect
        ) {
          const effect = move.effect;
          let effectApplied = false;
          let targetPokemon = null;
          let targetId = null;

          // Determine target of the effect
          if (effect.target === "self") {
            targetPokemon = attacker;
            targetId = attackerId;
          } else if (effect.target === "opponent") {
            targetPokemon = defender;
            targetId = defenderId;
          }

          if (targetPokemon) {
            const meetsChance = !effect.chance || Math.random() < effect.chance;

            // Apply Status Effect (Chance or Guaranteed) - immunity already checked
            if (
              (effect.type === "apply_status" ||
                effect.type === "apply_status_chance") &&
              meetsChance
            ) {
              effectApplied = targetPokemon.applyStatus(
                effect.status,
                attacker
              ); // applyStatus logs success/fail
              if (effectApplied) updateHPDisplay(targetPokemon, targetId); // Update UI for status badge
            }
            // Stat Change Effect
            else if (
              (effect.type === "lower_stat" ||
                effect.type === "raise_stat" ||
                effect.type === "lower_stat_chance" ||
                effect.type === "raise_stat_chance") &&
              meetsChance
            ) {
              // Check if stage change is possible before attempting
              const currentStage = targetPokemon.statStages[effect.stat];
              const potentialNewStage = currentStage + effect.stages;
              if (potentialNewStage >= -6 && potentialNewStage <= 6) {
                effectApplied = targetPokemon.changeStatStage(
                  effect.stat,
                  effect.stages
                ); // changeStatStage logs success/fail
              } else if (meetsChance) {
                // Log failure if chance was met but stat was maxed/minned
                log(
                  `${
                    targetPokemon.name
                  }'s ${effect.stat.toUpperCase()} won't go any ${
                    effect.stages > 0 ? "higher" : "lower"
                  }!`,
                  "stat-change"
                );
              }
            }
            // Heal Effect
            else if (effect.type === "heal_percent") {
              effectApplied = targetPokemon.heal(effect.amount);
              if (effectApplied) updateHPDisplay(targetPokemon, targetId); // Update UI for HP bar
            }
            // Add other effect types here (e.g., flinch, confusion - not implemented)

            if (effectApplied)
              await delay(
                ANIMATION_DELAY.STAT_CHANGE
              ); // Pause after successful effect message/visual
            else if (effect.chance && meetsChance && !effectApplied) {
              // If an effect had a chance, met the chance, but failed (e.g. stat maxed), pause slightly
              await delay(ANIMATION_DELAY.SHORT);
            }
          }
        } // end if(!fainted && move.effect)

        // Return fainted status based on events *within this move execution*
        return { fainted: defenderFaintedThisTurn || attackerFaintedThisTurn };
      }

      async function executeTurn(
        attacker,
        defender,
        attackerId,
        defenderId,
        chosenMove
      ) {
        // Double check faint status before starting
        if (attacker.isFainted || defender.isFainted || BATTLE_STATE.gameOver)
          return { battleEnded: BATTLE_STATE.gameOver };

        // Deactivate the opponent side visually
        const defenderSide = document.getElementById(
          defenderId === "pokemon1" ? "opponent-side" : "player-side"
        );
        defenderSide?.classList.remove("active");

        BATTLE_STATE.isProcessing = true; // Start processing lock for this action

        // --- Check Pre-Move Status Effects (Paralysis, Sleep, Freeze) ---
        const { canMove } = await handleStatusEffectsAtTurnStart(
          attacker,
          attackerId
        );
        if (!canMove) {
          // Apply end-of-turn status effects for the non-moving Pok√©mon if applicable (BRN/PSN)
          const { faintedFromStatus } = await handleStatusEffectsAtTurnEnd(
            attacker,
            attackerId
          );
          BATTLE_STATE.isProcessing = false; // End processing lock
          return { battleEnded: faintedFromStatus || BATTLE_STATE.gameOver };
        }

        // --- Activate Attacker Visually & Execute Move ---
        const attackerSide = document.getElementById(
          attackerId === "pokemon1" ? "opponent-side" : "player-side"
        );
        attackerSide?.classList.add("active"); // Activate JUST before moving

        const { fainted: moveCausedFaint } = await executeMove(
          attacker,
          defender,
          chosenMove,
          attackerId,
          defenderId
        );

        // If move caused a faint (either attacker or defender), the turn sequence might end here
        if (moveCausedFaint) {
          attackerSide?.classList.remove("active"); // Deactivate if fainted during move
          BATTLE_STATE.gameOver = attacker.isFainted || defender.isFainted; // Update global game over state
          BATTLE_STATE.isProcessing = false; // End processing lock
          return { battleEnded: BATTLE_STATE.gameOver };
        }

        // --- Apply End-of-Turn Status Effects (Burn, Poison) ---
        // Apply to the attacker *after* their successful move, unless they fainted from recoil already
        if (!attacker.isFainted) {
          const { faintedFromStatus } = await handleStatusEffectsAtTurnEnd(
            attacker,
            attackerId
          );
          if (faintedFromStatus) {
            attackerSide?.classList.remove("active"); // Deactivate if fainted from status
            BATTLE_STATE.gameOver = true; // Update global game over state
            BATTLE_STATE.isProcessing = false; // End processing lock
            return { battleEnded: true };
          }
        }

        // Attacker remains 'active' visually until the start of the next pokemon's action
        BATTLE_STATE.isProcessing = false; // End processing lock for this action
        return { battleEnded: BATTLE_STATE.gameOver }; // Return current game over state
      }

      async function startBattle(playerPokemonData, opponentPokemonData) {
        // Prevent starting new battle while one is processing
        if (BATTLE_STATE.isProcessing) return;
        BATTLE_STATE.isProcessing = true; // Lock processing during setup

        // --- Reset State ---
        BATTLE_STATE.gameOver = false;
        BATTLE_STATE.waitingForPlayer = false;
        BATTLE_STATE.isPlayerTurn = false;
        BATTLE_STATE.turnCounter = 0;
        BATTLE_STATE.battleLog = [];

        // Clear console & hide controls/restart button
        const consoleEl = document.getElementById("console");
        consoleEl.innerHTML = "";
        document.getElementById("player-controls").classList.add("hidden");
        document.getElementById("player-controls").innerHTML = "";
        document.getElementById("restart-button").classList.add("hidden");
        // Remove active/fainted classes from sides
        document
          .getElementById("opponent-side")
          ?.classList.remove("active", "fainted");
        document
          .getElementById("player-side")
          ?.classList.remove("active", "fainted");

        log(`‚ú® New Battle Starting! ‚ú®`);

        // --- Create Fresh Pokemon Instances ---
        BATTLE_STATE.playerPokemon = clonePokemon(playerPokemonData);
        BATTLE_STATE.opponentPokemon = clonePokemon(opponentPokemonData);

        log(`Opponent sent out <b>${BATTLE_STATE.opponentPokemon.name}</b>!`);
        await delay(ANIMATION_DELAY.SHORT);
        log(`Go! <b>${BATTLE_STATE.playerPokemon.name}</b>!`);
        await delay(ANIMATION_DELAY.SHORT);

        // --- Setup UI ---
        // Function to setup UI for one pokemon, returns a promise that resolves after animation
        function setupPokemonUI(pokemon, prefix) {
          return new Promise(async (resolve) => {
            // Mark inner function async
            const avatarContainerEl = document.getElementById(
              `${prefix}-avatar-container`
            );
            const avatarEl = document.getElementById(`${prefix}-avatar`);
            const nameEl = document.getElementById(`${prefix}-name`);
            const levelEl = document.getElementById(`${prefix}-level`);
            const sideEl = document.getElementById(
              prefix === "pokemon1" ? "opponent-side" : "player-side"
            );

            if (
              !avatarContainerEl ||
              !avatarEl ||
              !nameEl ||
              !levelEl ||
              !sideEl
            ) {
              console.error("UI Element missing for prefix:", prefix);
              resolve(); // Resolve anyway to not block the battle
              return;
            }

            // Reset visual states before setup
            sideEl.classList.remove("fainted", "active", "hit");
            avatarContainerEl.classList.remove("enter"); // Remove enter class first
            avatarEl.innerHTML = ""; // Clear previous avatar content
            avatarEl.classList.add("placeholder"); // Add placeholder class initially

            // Set text content
            nameEl.textContent = pokemon.name;
            levelEl.textContent = `Lv. ${pokemon.level}`;
            updateHPDisplay(pokemon, prefix); // Set initial HP and status

            // Load sprite
            if (pokemon.sprite) {
              const img = document.createElement("img");
              img.alt = pokemon.name;
              img.style.opacity = "0"; // Start transparent

              // Preload image before animating entry
              img.onload = () => {
                avatarEl.classList.remove("placeholder");
                avatarEl.appendChild(img);
                if (prefix === "pokemon2") {
                  // Player sprite faces right
                  img.style.transform = "scaleX(-1)";
                }

                // Force reflow before adding 'enter' class for animation start
                void avatarContainerEl.offsetWidth;
                avatarContainerEl.classList.add("enter");

                // Fade-in image slightly after container starts entry animation
                setTimeout(() => {
                  img.style.opacity = "1";
                }, 150);

                // Resolve the promise after the entry animation duration
                setTimeout(resolve, ANIMATION_DELAY.ENTRY);
              };
              img.onerror = () => {
                // Handle image loading error
                console.error("Failed to load sprite:", pokemon.sprite);
                // Keep placeholder visible
                void avatarContainerEl.offsetWidth; // Still trigger entry animation
                avatarContainerEl.classList.add("enter");
                setTimeout(resolve, ANIMATION_DELAY.ENTRY); // Resolve after duration
              };
              img.src = pokemon.sprite; // Start loading
            } else {
              // No sprite provided, just animate entry with placeholder
              void avatarContainerEl.offsetWidth;
              avatarContainerEl.classList.add("enter");
              setTimeout(resolve, ANIMATION_DELAY.ENTRY); // Resolve after duration
            }
          });
        }

        // Run UI setup sequentially with awaits
        await setupPokemonUI(BATTLE_STATE.opponentPokemon, "pokemon1");
        await setupPokemonUI(BATTLE_STATE.playerPokemon, "pokemon2");

        BATTLE_STATE.isProcessing = false; // Unlock processing after setup animations complete

        // --- Main Battle Loop ---
        while (
          !BATTLE_STATE.playerPokemon.isFainted &&
          !BATTLE_STATE.opponentPokemon.isFainted &&
          !BATTLE_STATE.gameOver
        ) {
          // Prevent loop iteration if still processing previous turn
          if (BATTLE_STATE.isProcessing) {
            await delay(50); // Short pause before checking again
            continue;
          }

          BATTLE_STATE.turnCounter++;
          log(`--- Turn ${BATTLE_STATE.turnCounter} ---`, "turn-divider");
          await delay(ANIMATION_DELAY.SHORT);

          // --- Move Selection Phase ---
          // Player selects move
          BATTLE_STATE.isPlayerTurn = true; // Enable controls via updatePlayerControls
          const playerMovePromise = new Promise((resolve) => {
            BATTLE_STATE.playerMoveResolver = resolve; // Store resolver
            const usablePlayerMoves = BATTLE_STATE.playerPokemon.moves.filter(
              (m) => m.currentPP > 0
            );
            if (
              usablePlayerMoves.length === 0 &&
              BATTLE_STATE.playerPokemon.hp > 0
            ) {
              log(`Player has no moves with PP left! Using <b>Struggle</b>.`);
              // No need to show controls, resolve immediately with Struggle
              setTimeout(() => resolve(MOVES.Struggle), ANIMATION_DELAY.SHORT);
            } else {
              updatePlayerControls(BATTLE_STATE.playerPokemon); // Show move buttons and set waitingForPlayer = true
            }
          });
          const playerChosenMove = await playerMovePromise;
          // --- Player choice logged inside executeMove ---
          BATTLE_STATE.isPlayerTurn = false; // Turn flag off after selection
          BATTLE_STATE.waitingForPlayer = false; // Not waiting anymore
          BATTLE_STATE.playerMoveResolver = null; // Clear resolver
          // Controls are already hidden by the button click handler

          // Opponent selects move
          const opponentChosenMove = chooseOpponentMove(
            BATTLE_STATE.opponentPokemon,
            BATTLE_STATE.playerPokemon
          );
          // --- Opponent choice logged inside executeMove ---
          // await delay(ANIMATION_DELAY.SHORT); // Short pause after selections are made internally

          // --- Determine Turn Order ---
          let firstAttacker, secondAttacker, firstDefender, secondDefender;
          let firstAttackerId,
            secondAttackerId,
            firstDefenderId,
            secondDefenderId;
          let firstMove, secondMove;

          const p1Priority = opponentChosenMove.priority || 0;
          const p2Priority = playerChosenMove.priority || 0;

          let p1GoesFirst;
          if (p1Priority > p2Priority) p1GoesFirst = true;
          else if (p2Priority > p1Priority) p1GoesFirst = false;
          else {
            // Priorities are equal, check speed
            const p1Speed = BATTLE_STATE.opponentPokemon.getModifiedStat("spe");
            const p2Speed = BATTLE_STATE.playerPokemon.getModifiedStat("spe");
            if (p1Speed > p2Speed) p1GoesFirst = true;
            else if (p2Speed > p1Speed) p1GoesFirst = false;
            else p1GoesFirst = Math.random() < 0.5; // Speed tie
          }

          if (p1GoesFirst) {
            [firstAttacker, firstDefender] = [
              BATTLE_STATE.opponentPokemon,
              BATTLE_STATE.playerPokemon,
            ];
            [secondAttacker, secondDefender] = [
              BATTLE_STATE.playerPokemon,
              BATTLE_STATE.opponentPokemon,
            ];
            [firstAttackerId, firstDefenderId] = ["pokemon1", "pokemon2"];
            [secondAttackerId, secondDefenderId] = ["pokemon2", "pokemon1"];
            [firstMove, secondMove] = [opponentChosenMove, playerChosenMove];
          } else {
            [firstAttacker, firstDefender] = [
              BATTLE_STATE.playerPokemon,
              BATTLE_STATE.opponentPokemon,
            ];
            [secondAttacker, secondDefender] = [
              BATTLE_STATE.opponentPokemon,
              BATTLE_STATE.playerPokemon,
            ];
            [firstAttackerId, firstDefenderId] = ["pokemon2", "pokemon1"];
            [secondAttackerId, secondDefenderId] = ["pokemon1", "pokemon2"];
            [firstMove, secondMove] = [playerChosenMove, opponentChosenMove];
          }

          // --- First Pok√©mon's Action ---
          let turnResult = await executeTurn(
            firstAttacker,
            firstDefender,
            firstAttackerId,
            firstDefenderId,
            firstMove
          );
          if (turnResult.battleEnded) {
            break; // Exit loop immediately if battle ended
          }
          await delay(ANIMATION_DELAY.TURN_TRANSITION);

          // --- Second Pok√©mon's Action ---
          // Check faint status BEFORE attempting second move (e.g. fainted from status/recoil from first attack)
          if (secondAttacker.isFainted || firstDefender.isFainted) {
            BATTLE_STATE.gameOver = true;
            break;
          }

          turnResult = await executeTurn(
            secondAttacker,
            secondDefender,
            secondAttackerId,
            secondDefenderId,
            secondMove
          );
          if (turnResult.battleEnded) {
            break; // Exit loop
          }

          // Check faint status again at the very end of the turn (e.g., both fainted from status)
          if (
            BATTLE_STATE.playerPokemon.isFainted ||
            BATTLE_STATE.opponentPokemon.isFainted
          ) {
            BATTLE_STATE.gameOver = true;
            break;
          }

          await delay(ANIMATION_DELAY.TURN_TRANSITION); // End of round pause
        } // End While Loop

        // --- Battle End ---
        BATTLE_STATE.gameOver = true;
        BATTLE_STATE.isPlayerTurn = false;
        BATTLE_STATE.isProcessing = false; // Ensure processing is unlocked
        document.getElementById("player-controls").classList.add("hidden");

        // Stop lingering 'active' animations
        document.getElementById("opponent-side")?.classList.remove("active");
        document.getElementById("player-side")?.classList.remove("active");

        // Determine winner/loser only after the loop confirms faint status
        const playerFainted = BATTLE_STATE.playerPokemon.isFainted;
        const opponentFainted = BATTLE_STATE.opponentPokemon.isFainted;

        let winnerMessage = "The battle ended in a draw?"; // Default case

        if (playerFainted && !opponentFainted) {
          winnerMessage = `üò≠ You lost! <b>${BATTLE_STATE.opponentPokemon.name}</b> wins the battle! üò≠`;
        } else if (opponentFainted && !playerFainted) {
          winnerMessage = `‚ú®üéâ <b>You Win!</b> ${BATTLE_STATE.playerPokemon.name} was victorious! üéâ‚ú®`;
        } else if (playerFainted && opponentFainted) {
          winnerMessage = "üí• It's a Double Knockout! The battle is a draw! üí•";
        }

        log(`--------------------`, "turn-divider");
        log(winnerMessage, "game-over");

        // Show restart button
        document.getElementById("restart-button").classList.remove("hidden");
      }

      // ********* MODULE: INITIALIZATION **************
      document.addEventListener("DOMContentLoaded", () => {
        const restartButton = document.getElementById("restart-button");

        const initiateBattle = () => {
          // Ensure not already processing before starting a new battle via button
          if (BATTLE_STATE.isProcessing && !BATTLE_STATE.gameOver) {
            // Allow restart if game is over
            console.log("Battle already in progress, cannot restart yet.");
            return;
          }

          // Select two different random Pok√©mon
          const pokemonKeys = Object.keys(POKEMON_DATA);
          if (pokemonKeys.length < 2) {
            console.error("Not enough Pok√©mon data to start a battle!");
            log("Error: Not enough Pok√©mon defined.", "danger-color");
            return;
          }

          let playerIndex = Math.floor(Math.random() * pokemonKeys.length);
          let opponentIndex;
          do {
            opponentIndex = Math.floor(Math.random() * pokemonKeys.length);
          } while (opponentIndex === playerIndex); // Ensure different Pok√©mon

          const playerPokemon = POKEMON_DATA[pokemonKeys[playerIndex]];
          const opponentPokemon = POKEMON_DATA[pokemonKeys[opponentIndex]];

          // Start the battle asynchronously
          startBattle(playerPokemon, opponentPokemon).catch((error) => {
            console.error("Battle execution failed:", error);
            log("A critical error occurred during the battle.", "danger-color");
            BATTLE_STATE.isProcessing = false; // Unlock processing on error
            document
              .getElementById("restart-button")
              .classList.remove("hidden"); // Show restart btn
          });
        };

        restartButton.addEventListener("click", initiateBattle);

        // Start the first battle automatically after a short delay for elements to render
        setTimeout(initiateBattle, 100); // Delay ensures smooth initial render
      });
    </script>
  </body>
</html>
