<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DrealR Imagineering Bubbles</title>
    <meta
      name="description"
      content="Explore unique, self-contained web experiments ('Bubbles') crafted by DrealR Imagineering using AI. Click a bubble to pop it and visit the creation!"
    />
    <style>
      :root {
        /* Core Dark Theme Palette */
        --color-background: #111827; /* Dark Blue/Gray */
        --color-text: #e5e7eb; /* Light Gray */
        --color-text-muted: #9ca3af; /* Medium Gray */
        --color-heading: #f9fafb; /* Almost White */
        --color-primary-accent: #38bdf8; /* Electric Blue */
        --color-secondary-accent: #ec4899; /* Vibrant Magenta */
        --color-focus-ring: var(--color-secondary-accent);

        /* Bubble Specific Palette */
        --color-bubble-bg-start: rgba(55, 65, 81, 0.5); /* Dark Gray semi-transparent */
        --color-bubble-bg-end: rgba(31, 41, 55, 0.6); /* Darker Gray semi-transparent */
        --color-bubble-border: rgba(107, 114, 128, 0.3); /* Subtle Gray Border */
        --color-bubble-border-hover: var(--color-primary-accent);
        --color-bubble-highlight: rgba(56, 189, 248, 0.15); /* Subtler blue highlight */
        --color-bubble-placeholder-bg-start: var(--color-primary-accent);
        --color-bubble-placeholder-bg-end: var(--color-secondary-accent);
        --color-bubble-placeholder-text: rgba(255, 255, 255, 0.85);
        --color-info-button-bg: rgba(17, 24, 39, 0.5); /* Very dark semi-transparent */
        --color-info-button-bg-hover: rgba(17, 24, 39, 0.8);
        --color-info-button-icon: var(--color-text-muted);
        --color-info-button-icon-hover: var(--color-heading);
        --color-tooltip-bg: #1f2937; /* Dark Gray 800 */
        --color-tooltip-text: var(--color-text);
        --color-tooltip-border: var(--color-bubble-border);
        --color-scrollbar-thumb: #4b5563; /* Gray 600 */
        --color-scrollbar-thumb-hover: #6b7280; /* Gray 500 */
        --color-scrollbar-track: rgba(17, 24, 39, 0.5); /* Darker BG */


        /* Filter Controls Palette */
        --color-filter-bg: rgba(55, 65, 81, 0.6);
        --color-filter-text: var(--color-text);
        --color-filter-border: var(--color-bubble-border);
        --color-filter-active-bg: var(--color-primary-accent);
        --color-filter-active-text: var(--color-background);
        --color-filter-hover-bg: rgba(75, 85, 99, 0.8);
        --color-search-bg: rgba(17, 24, 39, 0.5); /* Slightly darker for input */
        --color-search-shadow: rgba(0, 0, 0, 0.3);

        /* Typography & Fonts */
        --font-body: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, "Helvetica Neue", Arial, sans-serif;
        --font-heading: "Poppins", var(--font-body), sans-serif; /* Optional Poppins */
        --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;

        /* Spacing */
        --spacing-xs: 0.25rem; /* 4px */
        --spacing-sm: 0.5rem; /* 8px */
        --spacing-md: 1rem; /* 16px */
        --spacing-lg: 1.5rem; /* 24px */
        --spacing-xl: 2rem; /* 32px */
        --spacing-xxl: 3rem; /* 48px */

        /* Borders & Transitions */
        --border-radius-sm: 0.375rem; /* 6px */
        --border-radius-md: 0.75rem; /* 12px */
        --border-radius-lg: 1rem; /* 16px */
        --border-radius-bubble: 50%;
        --border-radius-pill: 9999px;
        --transition-duration-fast: 0.15s;
        --transition-duration-med: 0.3s;
        --transition-timing: cubic-bezier(0.4, 0, 0.2, 1);
        --transition-timing-bounce: cubic-bezier(0.68, -0.55, 0.27, 1.55);

        /* Bubble Dimensions & Animation */
        --bubble-size: clamp(200px, 22vw, 260px); /* Adjusted size range */
        --bubble-pop-duration: 0.45s; /* FASTER duration for pop */
        --bubble-pop-nav-delay-factor: 0.7; /* Navigate after 70% of pop duration */
        --bubble-reduced-motion-nav-delay: 50ms; /* Navigation delay for reduced motion */
        --glitch-intensity: 1.5px; /* Reduced intensity */
        --tooltip-z-index: 100;
        --pop-z-index: 1000; /* Ensure popping bubble is on top */

        /* Tooltip Specific */
        --tooltip-max-width: 350px;
        --tooltip-max-height: 300px; /* Constrain height */
        --tooltip-prompt-max-width: 450px; /* Slightly wider for prompts */
      }

      /* Optional: Load Poppins font if desired and connection available */
      /* @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap'); */

      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html {
        font-size: 100%;
        scroll-behavior: smooth;
        -webkit-text-size-adjust: 100%;
      }

      body {
        font-family: var(--font-body);
        background-color: var(--color-background);
        color: var(--color-text);
        line-height: 1.6;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow-x: hidden;
        position: relative;
      }

      /* Subtle Noise Background */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCI+DQo8ZmlsdGVyIGlkPSJub2lzZSIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSI+DQo8ZmVUdXJidWxlbmNlIHR5cGU9ImZyYWN0YWxOb2lzZSIgYmFzZUZyZXF1ZW5jeT0iMC45NSIgc3RpdGNoVGlsZXM9InN0aXRjaCIgbnVtT2N0YXZlcz0iMSIgcmVzdWx0PSJub2lzZSIvPg0KPGZlRGlmZnVzZUFtcGxpdHVkZSByZXN1bHQ9Im5vaXNlIiBpbj0ibm9pc2UiPjwvZmVEaWZmdXNlQW1wbGl0dWRlPg0KPC9maWx0ZXI+DQo8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWx0ZXI9InVybCgjbmlpZikiPjwvcmVjdD4NCjwvc3ZnPg==");
        background-repeat: repeat;
        opacity: 0.02;
        z-index: -1;
        pointer-events: none;
        animation: noise-animation 0.4s infinite linear alternate;
      }

      @keyframes noise-animation {
        0% { transform: translate(0, 0); }
        100% { transform: translate(1px, 1px); }
      }

      /* Basic Elements */
      h1, h2, h3 {
        font-family: var(--font-heading);
        color: var(--color-heading);
        line-height: 1.2;
        margin-bottom: var(--spacing-sm);
        letter-spacing: 0.02em;
        font-weight: 600;
      }

      h1 {
        font-size: clamp(2.2rem, 5vw + 1rem, 3.5rem);
        text-align: center;
        margin-bottom: var(--spacing-sm);
        font-weight: 800;
        letter-spacing: 0.04em;
        color: var(--color-heading);
        text-shadow: 0 0 5px rgba(56, 189, 248, 0.4),
          0 0 10px rgba(236, 72, 153, 0.25);
      }

      p {
        margin-bottom: var(--spacing-md);
        max-width: 70ch;
        color: var(--color-text);
      }
      p.intro-text {
        color: var(--color-text-muted);
        max-width: 65ch;
        margin: 0 auto var(--spacing-lg) auto;
        font-size: 1.05rem;
        line-height: 1.7;
      }

      a {
        color: var(--color-primary-accent);
        text-decoration: none;
        transition: color var(--transition-duration-fast) var(--transition-timing);
        border-radius: var(--border-radius-sm);
      }

      a:hover {
        color: var(--color-secondary-accent);
        text-decoration: underline;
        text-decoration-thickness: 1.5px;
        text-underline-offset: 4px;
      }

      a:focus { outline: none; }
      a:focus-visible {
        outline: 2px solid var(--color-focus-ring);
        outline-offset: 3px;
        color: var(--color-secondary-accent);
      }

      /* Layout Containers */
      .container {
        width: 90%;
        max-width: 1280px;
        margin-left: auto;
        margin-right: auto;
        padding-top: var(--spacing-xl);
        padding-bottom: var(--spacing-xl);
      }

      header {
        padding-top: var(--spacing-xl);
        padding-bottom: var(--spacing-lg);
        text-align: center;
        border-bottom: 1px solid var(--color-bubble-border);
        margin-bottom: var(--spacing-lg);
      }

      main { flex-grow: 1; }

      .bubble-showcase-wrapper { /* Wrapper for potential future needs */ }

      .bubble-showcase {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: var(--spacing-xl) var(--spacing-lg); /* Row gap, Column gap */
        padding: var(--spacing-lg) 0;
      }

      footer {
        text-align: center;
        padding: var(--spacing-lg) 0;
        margin-top: var(--spacing-xxl);
        border-top: 1px solid var(--color-bubble-border);
        color: var(--color-text-muted);
        font-size: 0.9rem;
      }

      /* Filter Controls - Refined Layout */
      .filter-controls {
        margin-bottom: var(--spacing-xl);
        padding: var(--spacing-lg);
        background-color: var(--color-filter-bg);
        border: 1px solid var(--color-filter-border);
        border-radius: var(--border-radius-md);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        display: flex;
        flex-direction: column; /* Stack groups vertically */
        gap: var(--spacing-md); /* Gap between groups */
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .filter-group {
        display: flex;
        flex-wrap: wrap;
        gap: var(--spacing-sm) var(--spacing-md); /* Row gap, Column gap */
        align-items: center;
        justify-content: center; /* Center items within group */
      }

      .filter-group:not(:last-child) {
         padding-bottom: var(--spacing-md); /* Space below group */
         border-bottom: 1px solid var(--color-filter-border); /* Separator */
      }

      .filter-group .filter-label {
        font-weight: 600;
        color: var(--color-text);
        margin-right: var(--spacing-sm);
        flex-shrink: 0;
        margin-bottom: var(--spacing-xs); /* Add space below label if wrapping */
        width: 100%; /* Make label take full width initially */
        text-align: center; /* Center label text */
        margin-right: 0; /* Reset margin */
      }

      /* Center buttons/input below the label */
      .filter-group > *:not(.filter-label) {
        margin-left: auto;
        margin-right: auto;
      }

      .filter-controls .filter-button {
        padding: var(--spacing-xs) var(--spacing-md);
        font-size: 0.9rem;
        font-weight: 500;
        border: 1px solid var(--color-filter-border);
        border-radius: var(--border-radius-pill);
        background-color: transparent;
        color: var(--color-filter-text);
        cursor: pointer;
        transition: background-color var(--transition-duration-fast) var(--transition-timing),
          color var(--transition-duration-fast) var(--transition-timing),
          border-color var(--transition-duration-fast) var(--transition-timing),
          transform var(--transition-duration-fast) var(--transition-timing);
        user-select: none;
        appearance: none;
      }

      .filter-controls .filter-button:hover {
        background-color: var(--color-filter-hover-bg);
        border-color: var(--color-primary-accent);
        transform: translateY(-2px);
        color: var(--color-heading);
      }

      .filter-controls .filter-button:focus { outline: none; }
      .filter-controls .filter-button:focus-visible {
        outline: 2px solid var(--color-focus-ring);
        outline-offset: 2px;
        border-color: var(--color-focus-ring);
      }

      .filter-controls .filter-button[aria-pressed="true"] {
        background-color: var(--color-filter-active-bg);
        color: var(--color-filter-active-text);
        border-color: var(--color-filter-active-bg);
        font-weight: 600;
      }

      /* Prompt Search Input Styling */
      .prompt-search-input {
        padding: var(--spacing-xs) var(--spacing-md);
        font-size: 0.9rem;
        font-family: var(--font-body);
        border: 1px solid var(--color-filter-border);
        border-radius: var(--border-radius-pill);
        background-color: var(--color-search-bg); /* Use specific search bg */
        color: var(--color-filter-text);
        transition: border-color var(--transition-duration-fast) var(--transition-timing),
                    box-shadow var(--transition-duration-fast) var(--transition-timing);
        flex-grow: 1; /* Allow it to take available space */
        min-width: 200px; /* Prevent being too small */
        max-width: 400px; /* Prevent being too large on wide screens */
        appearance: none;
        box-shadow: inset 0 1px 3px var(--color-search-shadow);
      }
      .prompt-search-input:focus {
        outline: none;
        border-color: var(--color-primary-accent);
        box-shadow: inset 0 1px 3px var(--color-search-shadow), 0 0 0 2px var(--color-focus-ring);
      }
      .prompt-search-input::placeholder {
        color: var(--color-text-muted);
        opacity: 0.8;
      }
      .prompt-search-input::-webkit-search-cancel-button,
      .prompt-search-input::-webkit-search-decoration { appearance: none; }

      /* Bubble Styling */
      .app-bubble {
        width: var(--bubble-size);
        height: var(--bubble-size);
        border-radius: var(--border-radius-bubble);
        background: linear-gradient(135deg, var(--color-bubble-bg-start), var(--color-bubble-bg-end));
        border: 1px solid var(--color-bubble-border);
        position: relative;
        overflow: visible; /* Allow info button/tooltip potentially outside */
        display: flex; /* Container for link content */
        cursor: pointer;
        transition: transform var(--transition-duration-med) var(--transition-timing),
          box-shadow var(--transition-duration-med) var(--transition-timing),
          border-color var(--transition-duration-med) var(--transition-timing),
          opacity var(--transition-duration-med) var(--transition-timing),
          visibility var(--transition-duration-med) linear;
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25), inset 0 1px 3px rgba(255, 255, 255, 0.05);
        will-change: transform, opacity;
        outline: none; /* Focus handled by focus-visible */
      }

      .app-bubble:hover,
      .app-bubble:focus-visible {
        transform: translateY(-6px) scale(1.04);
        border-color: var(--color-bubble-border-hover);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35), inset 0 1px 4px rgba(255, 255, 255, 0.08);
      }
      .app-bubble:focus-visible {
        outline: 3px solid var(--color-focus-ring);
        outline-offset: 5px;
      }

      /* Bubble highlight effect */
      .app-bubble::before {
        content: "";
        position: absolute;
        top: 8%;
        left: 15%;
        width: 60%;
        height: 30%;
        background: radial-gradient(ellipse at center, var(--color-bubble-highlight) 0%, transparent 70%);
        border-radius: 50%;
        opacity: 0.6;
        transform: rotate(-25deg);
        pointer-events: none;
        transition: opacity var(--transition-duration-med) ease, transform var(--transition-duration-med) ease;
        filter: blur(8px);
        z-index: 1; /* Above background, below content */
      }
      .app-bubble:hover::before {
        opacity: 0.8;
        transform: rotate(-20deg) scale(1.1);
      }

      /* Glitchy border effect */
      .app-bubble::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 1.5px solid var(--color-secondary-accent);
        border-radius: inherit;
        opacity: 0;
        transition: opacity var(--transition-duration-med) ease-in-out, transform var(--transition-duration-med) ease-in-out;
        pointer-events: none;
        z-index: 0;
        transform: translate(0, 0);
      }
      .app-bubble:hover::after,
      .app-bubble:focus-within::after { /* Trigger on focus within */
        opacity: 0.35; /* Slightly reduced opacity */
        animation: bubble-glitch 0.6s infinite alternate linear; /* Slightly slower */
      }

      @keyframes bubble-glitch {
        0% {
          transform: translate(var(--glitch-intensity), calc(var(--glitch-intensity) * -1));
          clip-path: polygon(0% 0%, 100% 0%, 100% 45%, 0% 55%);
        }
        100% {
          transform: translate(calc(var(--glitch-intensity) * -1), var(--glitch-intensity));
          clip-path: polygon(0% 55%, 100% 45%, 100% 100%, 0% 100%);
        }
      }

      /* Filtered out state */
      .app-bubble.hidden {
        opacity: 0;
        transform: scale(0.8);
        pointer-events: none;
        visibility: hidden;
        transition: opacity var(--transition-duration-med) var(--transition-timing),
          transform var(--transition-duration-med) var(--transition-timing),
          visibility 0s linear var(--transition-duration-med),
          width 0s linear var(--transition-duration-med), /* Immediate collapse */
          height 0s linear var(--transition-duration-med),
          padding 0s linear var(--transition-duration-med),
          margin 0s linear var(--transition-duration-med),
          border 0s linear var(--transition-duration-med),
          gap 0s linear var(--transition-duration-med);

        /* Collapse the space */
        width: 0 !important;
        height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
        border: none !important;
        overflow: hidden !important;
        gap: 0 !important; /* Reset gap contribution */
      }

      .bubble-link-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        padding: var(--spacing-sm);
        color: var(--color-heading);
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        text-align: center;
        position: relative;
        z-index: 2; /* Above pseudo-elements */
        text-decoration: none; /* Ensure no underline */
        border-radius: inherit; /* Make link area match bubble shape */
        outline: none; /* Remove focus outline from link itself */
      }

      .bubble-image-placeholder {
        width: 35%;
        aspect-ratio: 1 / 1; /* Maintain square */
        height: auto; /* Let aspect-ratio define height */
        border-radius: 50%;
        background: linear-gradient(45deg, var(--color-bubble-placeholder-bg-start), var(--color-bubble-placeholder-bg-end));
        opacity: 0.65; /* Slightly more opaque */
        margin-bottom: var(--spacing-sm);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.6rem;
        color: var(--color-bubble-placeholder-text);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 2px 5px rgba(0, 0, 0, 0.2);
        flex-shrink: 0;
      }

      .app-bubble h3 {
        font-size: clamp(0.9rem, 1.5vw + 0.5rem, 1.15rem);
        font-weight: 600;
        margin-bottom: var(--spacing-xs);
        color: var(--color-heading);
        max-width: 90%; /* Prevent title touching edges/info button */
        line-height: 1.3;
        overflow-wrap: break-word; /* Break long words if needed */
      }

      .app-bubble .model-name {
        font-size: 0.75rem;
        color: var(--color-text-muted);
        font-weight: 400;
        display: block;
        margin-top: var(--spacing-xs);
        line-height: 1.3;
      }

      /* Refinements Info */
      .app-bubble .generation-refinements {
        font-size: 0.7rem;
        color: var(--color-text-muted);
        font-weight: 400;
        display: block;
        margin-top: var(--spacing-sm);
        opacity: 0.8;
        cursor: help; /* Indicate interaction */
        text-decoration: underline dashed 1px;
        text-decoration-color: rgba(156, 163, 175, 0.5);
        text-underline-offset: 2px;
        transition: color var(--transition-duration-fast), text-decoration-color var(--transition-duration-fast), opacity var(--transition-duration-fast);
        border-radius: var(--border-radius-sm);
        padding: var(--spacing-xs);
        margin: var(--spacing-sm) calc(var(--spacing-xs) * -1) 0; /* Adjust margin for padding */
        line-height: 1.3;
        max-width: calc(100% - 50px); /* Prevent overlap with info button */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        outline: none; /* Focus handled by focus-visible */
      }

      .app-bubble .generation-refinements:hover,
      .app-bubble .generation-refinements:focus {
        color: var(--color-text);
        opacity: 1;
        text-decoration-color: var(--color-primary-accent);
      }
      .app-bubble .generation-refinements:focus-visible {
        outline: 2px solid var(--color-focus-ring);
        outline-offset: 1px;
        opacity: 1; /* Ensure visibility on focus */
      }

      /* Info Button */
      .info-button {
        position: absolute;
        top: var(--spacing-md);
        right: var(--spacing-md);
        z-index: 3; /* Above content, below tooltip */
        padding: 0; /* Padding handled by size */
        margin: 0;
        background-color: var(--color-info-button-bg);
        border: 1px solid var(--color-bubble-border);
        border-radius: 50%;
        cursor: help;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        color: var(--color-info-button-icon);
        opacity: 0; /* Hidden by default */
        transform: scale(0.8);
        transition: opacity var(--transition-duration-fast) ease-in-out,
          transform var(--transition-duration-fast) ease-in-out,
          background-color var(--transition-duration-fast) ease-in-out,
          color var(--transition-duration-fast) ease-in-out;
        backdrop-filter: blur(3px);
        -webkit-backdrop-filter: blur(3px);
        appearance: none;
        outline: none; /* Focus handled by focus-visible */
      }
      .app-bubble:hover .info-button,
      .app-bubble:focus-within .info-button,
      .info-button:focus-visible /* Keep visible when focused itself */ {
        opacity: 1;
        transform: scale(1);
      }

      .info-button svg {
        width: 16px;
        height: 16px;
        display: block;
      }

      .info-button:hover,
      .info-button:focus {
        background-color: var(--color-info-button-bg-hover);
        color: var(--color-info-button-icon-hover);
        border-color: var(--color-primary-accent);
        transform: scale(1.1); /* Slightly larger on hover/focus */
      }
      .info-button:focus-visible {
        outline: 2px solid var(--color-focus-ring);
        outline-offset: 2px;
        transform: scale(1.1); /* Maintain scale on focus */
      }

      /* --- Unified Tooltip Styling --- */
      #bubble-tooltip {
        position: fixed; /* Relative to viewport */
        z-index: var(--tooltip-z-index);
        background-color: var(--color-tooltip-bg);
        color: var(--color-tooltip-text);
        border: 1px solid var(--color-tooltip-border);
        border-radius: var(--border-radius-md);
        padding: var(--spacing-md);
        /* Add right padding for scrollbar space */
        padding-right: calc(var(--spacing-md) + var(--spacing-sm));
        font-size: 0.85rem;
        line-height: 1.5;
        max-width: var(--tooltip-max-width); /* Default max-width */
        max-height: var(--tooltip-max-height); /* *** ADDED: Constrain height *** */
        overflow-y: auto; /* *** ADDED: Enable scrolling *** */
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: translateY(10px) scale(0.95);
        transition: opacity var(--transition-duration-fast) var(--transition-timing),
          visibility 0s linear var(--transition-duration-fast),
          transform var(--transition-duration-fast) var(--transition-timing);
        white-space: pre-wrap; /* Preserve line breaks and spaces */
        word-wrap: break-word;
        font-family: var(--font-body);
        scrollbar-width: thin; /* Firefox */
        scrollbar-color: var(--color-scrollbar-thumb) var(--color-scrollbar-track); /* Firefox */
      }

      /* Webkit scrollbar styles */
      #bubble-tooltip::-webkit-scrollbar {
        width: 8px;
      }
      #bubble-tooltip::-webkit-scrollbar-track {
        background: var(--color-scrollbar-track);
        border-radius: var(--border-radius-md);
      }
      #bubble-tooltip::-webkit-scrollbar-thumb {
        background-color: var(--color-scrollbar-thumb);
        border-radius: 4px;
        border: 2px solid var(--color-scrollbar-track);
      }
      #bubble-tooltip::-webkit-scrollbar-thumb:hover {
        background-color: var(--color-scrollbar-thumb-hover);
      }


      #bubble-tooltip[data-type="prompt"] {
        font-family: var(--font-mono);
        max-width: var(--tooltip-prompt-max-width); /* Wider for prompts */
      }
      /* Refinement tooltips don't need specific styles, inherit default */

      #bubble-tooltip.visible {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateY(0) scale(1);
        transition-delay: 0s, 0s, 0s; /* Reset delays */
      }

      /* --- FASTER Pop Animation --- */
      @keyframes bubble-pop-fast {
        0% { transform: scale(1) rotate(0deg); opacity: 1; }
        20% {
          transform: scale(0.8) rotate(-4deg); opacity: 0.95;
          animation-timing-function: cubic-bezier(0.34, 1.56, 0.64, 1); /* Overshoot */
        }
        65% {
          transform: scale(20) rotate(3deg); opacity: 1;
          animation-timing-function: cubic-bezier(0.165, 0.84, 0.44, 1); /* EaseOutQuad */
        }
        100% { transform: scale(25) rotate(0deg); opacity: 0; }
      }

      .app-bubble.popping {
        /* Position/size/zIndex/margin set dynamically by JS */
        transform-origin: center center;
        will-change: transform, opacity;
        animation: bubble-pop-fast var(--bubble-pop-duration) forwards;
        cursor: default;
        pointer-events: none;
        background: linear-gradient(135deg, var(--color-bubble-bg-start), var(--color-bubble-bg-end));
        border: 1px solid var(--color-bubble-border); /* Keep border */
        border-radius: var(--border-radius-bubble); /* Keep shape */
        box-shadow: none; /* Remove original shadow */
        backdrop-filter: none; /* Remove blur during pop */
        -webkit-backdrop-filter: none;
        overflow: hidden; /* Hide internal content cleanly */
      }
      .app-bubble.popping > * {
        opacity: 0 !important;
        visibility: hidden !important;
        transition: none !important;
      }
      .app-bubble.popping::before,
      .app-bubble.popping::after {
        display: none !important;
        content: none !important;
        animation: none !important;
      }

      /* Empty state message */
      .empty-state {
        text-align: center;
        color: var(--color-text-muted);
        padding: var(--spacing-xl);
        border: 2px dashed var(--color-bubble-border);
        border-radius: var(--border-radius-md);
        width: calc(100% - var(--spacing-lg) * 2);
        margin: var(--spacing-lg) auto;
        display: none; /* Hidden by default */
      }
      .empty-state.visible { display: block; }

      /* Accessibility */
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
      }

      /* Media Queries */
      @media (max-width: 768px) {
        h1 { font-size: clamp(2rem, 8vw, 3rem); }
        .container { width: 95%; }
        .bubble-showcase { gap: var(--spacing-lg); }

        .filter-group { gap: var(--spacing-sm); }
        .filter-group .filter-label { margin-bottom: var(--spacing-sm); }
        .prompt-search-input { max-width: 90%; min-width: 180px; }

        .info-button {
          top: var(--spacing-sm);
          right: var(--spacing-sm);
          width: 24px;
          height: 24px;
        }
        .info-button svg { width: 14px; height: 14px; }

        #bubble-tooltip {
          max-width: 90vw; /* Allow tooltip to take more width */
          font-size: 0.8rem;
          /* Adjust max-height slightly for smaller screens if needed */
          --tooltip-max-height: 250px;
        }
        /* No need to override data-type specific max-width here, 90vw covers it */
      }

      @media (max-width: 480px) {
        p.intro-text { font-size: 1rem; }
        .app-bubble h3 { font-size: 0.85rem; }
        .app-bubble .model-name { font-size: 0.7rem; }
        .app-bubble .generation-refinements {
          font-size: 0.65rem;
          max-width: calc(100% - 40px);
        }
        .bubble-image-placeholder { width: 30%; }
        .filter-controls { padding: var(--spacing-md); }
        .filter-group { gap: var(--spacing-xs) var(--spacing-sm); }
        .filter-controls .filter-button {
          font-size: 0.85rem;
          padding: var(--spacing-xs) var(--spacing-sm);
        }
        .prompt-search-input {
          font-size: 0.85rem;
          padding: var(--spacing-xs) var(--spacing-sm);
          max-width: 100%; /* Allow full width */
        }
         /* Further reduce tooltip height on very small screens */
        #bubble-tooltip {
            --tooltip-max-height: 200px;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        body::before,
        .app-bubble::after { animation: none !important; }
        .app-bubble, .filter-button, .app-bubble::before, .app-bubble::after,
        .info-button, #bubble-tooltip, .generation-refinements {
          transition-duration: 0.01ms !important;
          transition-delay: 0ms !important;
        }
        .app-bubble.popping {
          animation: none !important;
          opacity: 0 !important;
          transform: scale(0) !important;
          transition: opacity 0.05s linear, transform 0.05s linear !important;
        }
        .app-bubble:hover, .app-bubble:focus-visible, .app-bubble:focus-within { transform: none; }
        .app-bubble:hover::before { transform: rotate(-25deg); }
        .info-button { transform: scale(1); }
        .info-button:hover, .info-button:focus { transform: scale(1); }
        #bubble-tooltip { transform: translateY(0) scale(1); }
        .filter-button:hover { transform: none; }
      }
    </style>
  </head>
  <body>
    <header class="container">
      <h1>DrealR Imagineering Bubbles</h1>
      <p class="intro-text">
        Welcome! These self-contained web experiences, or 'Bubbles', are simple
        HTML files – each a unique digital creation. Planted by a human prompt,
        they are grown and refined collaboratively with AI assistants. Click a
        bubble to pop it and explore! Use the
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style="width: 1em; height: 1em; vertical-align: -0.125em; display: inline-block; color: var(--color-info-button-icon);" aria-hidden="true">
          <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
        </svg>
        icon for initial prompts and hover over or focus "Refinements" for
        iteration details. Filter or search below.
      </p>

      <div class="filter-controls" role="toolbar" aria-label="Filter apps by AI Model and Search Prompts">
        <div class="filter-group model-filters">
          <span class="filter-label" id="filter-label-model">Filter by Model:</span>
          <button type="button" class="filter-button" data-filter="all" aria-pressed="true" aria-describedby="filter-label-model">All</button>
          <button type="button" class="filter-button" data-filter="gemini-2.5-pro" aria-pressed="false" aria-describedby="filter-label-model">Gemini 2.5 Pro</button>
          <button type="button" class="filter-button" data-filter="claude-3.7-thinking" aria-pressed="false" aria-describedby="filter-label-model">Claude 3.7 thinking</button>
          <button type="button" class="filter-button" data-filter="nightwhisper" aria-pressed="false" aria-describedby="filter-label-model">Nightwhisper</button>
          <!-- Add more filter buttons here -->
        </div>
        <div class="filter-group prompt-filter">
            <label for="prompt-search" class="filter-label">Search Prompts:</label>
            <input type="search" id="prompt-search" class="prompt-search-input" placeholder="e.g., game, simulator, css..." aria-label="Search prompts">
        </div>
      </div>
    </header>

    <main class="container">
      <section class="bubble-showcase-wrapper" aria-labelledby="showcase-heading">
        <h2 id="showcase-heading" class="sr-only">App Bubble Showcase</h2>
        <div class="bubble-showcase" id="bubble-grid" aria-live="polite" aria-atomic="true">
          <!-- Announce changes when filters are applied -->

          <!-- Bubble 1: Pokémon Battle Simulator -->
          <article class="app-bubble" data-model="gemini-2.5-pro" tabindex="0" aria-labelledby="gemini-app1-title">
            <a href="pokemon-sim-gemini.html" class="bubble-link-content" tabindex="-1" aria-hidden="true">
              <div class="bubble-image-placeholder" aria-hidden="true">IMG</div>
              <h3 id="gemini-app1-title">Pokémon Battle Simulator</h3>
              <span class="model-name">Gemini 2.5 Pro</span>
              <span class="generation-refinements" tabindex="0" aria-describedby="bubble-tooltip" data-tooltip-type="refinement" data-tooltip-content="Developed over 3 refinement iterations with the AI.">Refinements: 3</span>
            </a>
            <button type="button" class="info-button" aria-label="View Prompt for Pokémon Battle Simulator" aria-describedby="bubble-tooltip" data-tooltip-type="prompt" data-tooltip-content="Generate JavaScript code for a turn-based Pokémon battle simulator engine. Style it as if it's an apple expert designer. When the character is active, add a smooth animation bouncing on the avatar. Make it like a battle in a 2d map, left vs right, when a Pokémon attacks it will be animated in a cool way to attack the other character of the other side. Given the attack type, for example if its fire, we generate fire icons that start from the character and go smoothly attacking the enemy, it should look really flowing smoothly

**Core Requirements:**

1.  **Pokémon Representation:** Create a way to represent Pokémon using JavaScript objects. Each Pokémon must have at least:
    *   `name` (string)
    *   `hp` (number, current hit points)
    *   `maxHp` (number, maximum hit points)
    *   `types` (array of strings, e.g., `['Fire']`, `['Water', 'Rock']`)
    *   `moves` (array of move objects)

2.  **Move Representation:** Create a way to represent moves using JavaScript objects. Each move must have at least:
    *   `name` (string)
    *   `type` (string, e.g., 'Grass', 'Normal')
    *   `power` (number, base damage)
    *   `accuracy` (number between 0 and 1, chance to hit)

3.  **Type Effectiveness:** Implement the classic Rock-Paper-Scissors elemental type effectiveness logic. Use the following basic chart (feel free to represent this efficiently, e.g., using an object or map):
    *   Fire > Grass (2x damage)
    *   Grass > Water (2x damage)
    *   Water > Fire (2x damage)
    *   Fire < Water (0.5x damage)
    *   Grass < Fire (0.5x damage)
    *   Water < Grass (0.5x damage)
    *   *All other interactions are 1x damage.*
    *   Handle dual types: If a target has two types, calculate the multiplier for each type against the move's type and multiply them together (e.g., Water move vs Fire/Rock target: Water vs Fire = 2x, Water vs Rock = 2x, total multiplier = 4x).

4.  **Battle Flow:**
    *   The simulation should take two Pokémon objects as input.
    *   Implement a turn-based loop. On each turn, one Pokémon uses a move against the other. (For simplicity, assume a fixed turn order or alternate turns).
    *   When a move is used:
        *   Check if the move hits based on its `accuracy`.
        *   If it hits, calculate damage: `damage = move.power * typeEffectivenessMultiplier`.
        *   Subtract the damage from the target Pokémon's `hp`.
        *   Ensure HP doesn't go below 0.
    *   The battle ends when one Pokémon's `hp` reaches 0.

5.  **Output:** Log the key events of the battle to the console (e.g., "Pikachu used Thunderbolt!", "It's super effective!", "Charizard took 35 damage.", "Charizard fainted!").

**Novelty Element: Synergy Resonance**

6.  **Implement 'Synergy Resonance':**
    *   Each Pokémon object should also have a `resonance` property, starting at 0.
    *   When a Pokémon lands a **super effective** hit, its `resonance` increases by 1.
    *   When a Pokémon takes a **not very effective** hit (resists the attack), its `resonance` increases by 1.
    *   When a Pokémon's `resonance` reaches 3 or more:
        *   The *next* move it uses that matches one of its *own types* (STAB - Same Type Attack Bonus) gets an additional +10 power bonus *before* type effectiveness is calculated.
        *   After using this boosted move, the Pokémon's `resonance` resets to 0.
    *   Log console messages when resonance increases and when the boosted attack occurs.

**Code Structure:**

*   Aim for clear, well-commented functions (e.g., `calculateTypeEffectiveness(moveType, targetTypes)`, `calculateDamage(...)`, `executeTurn(...)`, `startBattle(...)`).
*   Include example Pokémon and move data to run a sample battle.

**Example Scenario to Test:**

*   A pure 'Fire' type Pokémon (e.g., Charmander) vs a pure 'Grass' type Pokémon (e.g., Bulbasaur).
*   Charmander uses a 'Fire' move, hits super effectively, gains 1 resonance.
*   Bulbasaur uses a 'Grass' move, hits not very effectively, Charmander gains 1 resonance.
*   Charmander uses another 'Fire' move, hits super effectively, gains 1 resonance (now at 3).
*   The *next* 'Fire' move Charmander uses should activate Synergy Resonance, gain +10 power, deal damage, and reset Charmander's resonance to 0.">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
              </svg>
            </button>
            <span class="sr-only">(Opens Pokémon Battle Simulator generated by Gemini 2.5 Pro)</span>
          </article>

          <!-- Bubble 2: Pokémon Catch Game -->
          <article class="app-bubble" data-model="claude-3.7-thinking" tabindex="0" aria-labelledby="claude-app1-title">
            <a href="poke-catch-sonnet.html" class="bubble-link-content" tabindex="-1" aria-hidden="true">
              <div class="bubble-image-placeholder" aria-hidden="true">IMG</div>
              <h3 id="claude-app1-title">Pokémon Catch Game</h3>
              <span class="model-name">Claude 3.7 thinking</span>
              <span class="generation-refinements" tabindex="0" aria-describedby="bubble-tooltip" data-tooltip-type="refinement" data-tooltip-content="Developed over 1 refinement iteration with the AI.">Refinements: 1</span>
            </a>
            <button type="button" class="info-button" aria-label="View Prompt for Pokémon Catch Game" aria-describedby="bubble-tooltip" data-tooltip-type="prompt" data-tooltip-content="Create a pokemon game">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
              </svg>
            </button>
            <span class="sr-only">(Opens Pokémon Catch Game generated by Claude 3.7 thinking)</span>
          </article>

          <!-- Bubble 3: Pokémon Battle Arena -->
          <article class="app-bubble" data-model="nightwhisper" tabindex="0" aria-labelledby="nightwhisper-app1-title">
            <a href="pokemon-sim-nightwhisper.html" class="bubble-link-content" tabindex="-1" aria-hidden="true">
              <div class="bubble-image-placeholder" aria-hidden="true">IMG</div>
              <h3 id="nightwhisper-app1-title">Pokémon Battle Arena</h3>
              <span class="model-name">Nightwhisper</span>
              <span class="generation-refinements" tabindex="0" aria-describedby="bubble-tooltip" data-tooltip-type="refinement" data-tooltip-content="Developed over 1 refinement iteration with the AI.">Refinements: 1</span>
            </a>
            <button type="button" class="info-button" aria-label="View Prompt for Pokémon Battle Arena" aria-describedby="bubble-tooltip" data-tooltip-type="prompt" data-tooltip-content="Generate JavaScript code for a turn-based Pokémon battle simulator engine. Style it as if it's an apple expert designer. When the character is active, add a smooth animation bouncing on the avatar. Make it like a battle in a 2d map, left vs right, when a Pokémon attacks it will be animated in a cool way to attack the other character of the other side. Given the attack type, for example if its fire, we generate fire icons that start from the character and go smoothly attacking the enemy, it should look really flowing smoothly

**Core Requirements:**

1.  **Pokémon Representation:** Create a way to represent Pokémon using JavaScript objects. Each Pokémon must have at least:
    *   `name` (string)
    *   `hp` (number, current hit points)
    *   `maxHp` (number, maximum hit points)
    *   `types` (array of strings, e.g., `['Fire']`, `['Water', 'Rock']`)
    *   `moves` (array of move objects)

2.  **Move Representation:** Create a way to represent moves using JavaScript objects. Each move must have at least:
    *   `name` (string)
    *   `type` (string, e.g., 'Grass', 'Normal')
    *   `power` (number, base damage)
    *   `accuracy` (number between 0 and 1, chance to hit)

3.  **Type Effectiveness:** Implement the classic Rock-Paper-Scissors elemental type effectiveness logic. Use the following basic chart (feel free to represent this efficiently, e.g., using an object or map):
    *   Fire > Grass (2x damage)
    *   Grass > Water (2x damage)
    *   Water > Fire (2x damage)
    *   Fire < Water (0.5x damage)
    *   Grass < Fire (0.5x damage)
    *   Water < Grass (0.5x damage)
    *   *All other interactions are 1x damage.*
    *   Handle dual types: If a target has two types, calculate the multiplier for each type against the move's type and multiply them together (e.g., Water move vs Fire/Rock target: Water vs Fire = 2x, Water vs Rock = 2x, total multiplier = 4x).

4.  **Battle Flow:**
    *   The simulation should take two Pokémon objects as input.
    *   Implement a turn-based loop. On each turn, one Pokémon uses a move against the other. (For simplicity, assume a fixed turn order or alternate turns).
    *   When a move is used:
        *   Check if the move hits based on its `accuracy`.
        *   If it hits, calculate damage: `damage = move.power * typeEffectivenessMultiplier`.
        *   Subtract the damage from the target Pokémon's `hp`.
        *   Ensure HP doesn't go below 0.
    *   The battle ends when one Pokémon's `hp` reaches 0.

5.  **Output:** Log the key events of the battle to the console (e.g., "Pikachu used Thunderbolt!", "It's super effective!", "Charizard took 35 damage.", "Charizard fainted!").

**Novelty Element: Synergy Resonance**

6.  **Implement 'Synergy Resonance':**
    *   Each Pokémon object should also have a `resonance` property, starting at 0.
    *   When a Pokémon lands a **super effective** hit, its `resonance` increases by 1.
    *   When a Pokémon takes a **not very effective** hit (resists the attack), its `resonance` increases by 1.
    *   When a Pokémon's `resonance` reaches 3 or more:
        *   The *next* move it uses that matches one of its *own types* (STAB - Same Type Attack Bonus) gets an additional +10 power bonus *before* type effectiveness is calculated.
        *   After using this boosted move, the Pokémon's `resonance` resets to 0.
    *   Log console messages when resonance increases and when the boosted attack occurs.

**Code Structure:**

*   Aim for clear, well-commented functions (e.g., `calculateTypeEffectiveness(moveType, targetTypes)`, `calculateDamage(...)`, `executeTurn(...)`, `startBattle(...)`).
*   Include example Pokémon and move data to run a sample battle.

**Example Scenario to Test:**

*   A pure 'Fire' type Pokémon (e.g., Charmander) vs a pure 'Grass' type Pokémon (e.g., Bulbasaur).
*   Charmander uses a 'Fire' move, hits super effectively, gains 1 resonance.
*   Bulbasaur uses a 'Grass' move, hits not very effectively, Charmander gains 1 resonance.
*   Charmander uses another 'Fire' move, hits super effectively, gains 1 resonance (now at 3).
*   The *next* 'Fire' move Charmander uses should activate Synergy Resonance, gain +10 power, deal damage, and reset Charmander's resonance to 0.">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
              </svg>
            </button>
            <span class="sr-only">(Opens Pokémon Battle Arena generated by Nightwhisper)</span>
          </article>

          <!-- Add more app bubbles here -->
        </div>
        <div class="empty-state" id="empty-state-message">
          <p>No bubbles match the selected filters. Try adjusting them!</p>
        </div>
      </section>
    </main>

    <footer>
      <div class="container">
        <p>© DrealR Imagineering</p>
      </div>
    </footer>

    <!-- Single Unified Tooltip Element -->
    <div id="bubble-tooltip" role="tooltip" aria-hidden="true"></div>

    <script>
      /**
       * @typedef {Object} AppBubbleData
       * @property {HTMLElement} element - The bubble's main HTML element (<article>).
       * @property {string} model - The AI model associated with the bubble.
       * @property {string | null} link - The destination URL for the bubble.
       * @property {HTMLButtonElement | null} infoButton - The info button element.
       * @property {HTMLElement | null} refinementSpan - The refinement info span element.
       * @property {string} prompt - The lowercase prompt text associated with the bubble.
       */

      /**
       * Manages the filtering, interaction, and tooltips of AI-generated app bubbles.
       */
      class BubbleShowcase {
        /**
         * Initializes the bubble showcase functionality.
         */
        constructor() {
          this.filterControls = document.querySelector(".filter-controls");
          this.bubbleGrid = document.getElementById("bubble-grid");
          this.emptyStateMessage = document.getElementById("empty-state-message");
          this.tooltipElement = document.getElementById("bubble-tooltip");
          this.promptSearchInput = document.getElementById('prompt-search');
          this.popZIndex = this.getCssVariableValue("--pop-z-index", "1000"); // Get z-index for popping

          if (!this.filterControls || !this.bubbleGrid || !this.emptyStateMessage || !this.tooltipElement || !this.promptSearchInput) {
            console.error("Bubble Showcase Error: Required elements missing (controls, grid, empty state, tooltip, or search input).");
            return;
          }

          /** @type {AppBubbleData[]} */
          this.appBubbles = [];
          this.activeModelFilter = 'all'; // Initial model filter
          this.activePromptFilter = '';   // Initial prompt filter
          this.searchTimeout = null;      // Timeout for debouncing search input
          this.initBubbles(); // Populate appBubbles array

          this.filterButtons = this.filterControls.querySelectorAll(".filter-button");
          this.popAnimationDuration = this.getCssVariableDuration("--bubble-pop-duration", 450); // Default: 0.45s
          this.popNavDelayFactor = this.getCssVariableNumber("--bubble-pop-nav-delay-factor", 0.7); // Default: 70%
          this.reducedMotionNavDelay = this.getCssVariableDuration("--bubble-reduced-motion-nav-delay", 50); // Default: 50ms

          /** @type {HTMLElement | null} */
          this.activeTooltipTrigger = null; // Track which element triggered the tooltip
          /** @type {number | null} */
          this.hideTooltipTimeout = null; // Timeout reference for delayed hiding
          /** @type {ResizeObserver | null} */
          this.resizeObserver = null; // For repositioning tooltip on resize/scroll
          /** @type {Function | null} */
          this.scrollListener = null; // Reference to the scroll listener

          this.addEventListeners();
          this.filterBubbles(); // Apply initial filters (all, empty search)
          this.initPositionObserver(); // Initialize observer for tooltip repositioning
        }

        /**
         * Parses bubble elements from the DOM and populates the this.appBubbles array.
         */
        initBubbles() {
          this.appBubbles = Array.from(this.bubbleGrid.querySelectorAll(".app-bubble")).map((bubbleEl) => {
            const linkContent = bubbleEl.querySelector("a.bubble-link-content");
            const infoButton = bubbleEl.querySelector(".info-button");
            const refinementSpan = bubbleEl.querySelector(".generation-refinements");
            const promptContent = infoButton?.dataset.tooltipContent || '';
            return {
              element: bubbleEl,
              model: bubbleEl.dataset.model || "unknown",
              link: linkContent?.getAttribute("href"),
              infoButton: infoButton,
              refinementSpan: refinementSpan,
              prompt: promptContent.toLowerCase() // Store lowercase prompt
            };
          });
        }

        /**
         * Gets a raw CSS Custom Property value or fallback.
         * @param {string} propertyName - The CSS custom property name.
         * @param {string} fallbackValue - The fallback value.
         * @returns {string} The property value or fallback.
         */
        getCssVariableValue(propertyName, fallbackValue) {
          try {
            const value = getComputedStyle(document.documentElement).getPropertyValue(propertyName).trim();
            return value || fallbackValue;
          } catch (e) {
            console.warn(`Could not read CSS variable ${propertyName}:`, e);
            return fallbackValue;
          }
        }

        /**
         * Gets animation duration from CSS Custom Property or uses fallback.
         * @param {string} propertyName - The CSS custom property name.
         * @param {number} fallbackMs - The fallback duration in milliseconds.
         * @returns {number} Duration in milliseconds.
         */
        getCssVariableDuration(propertyName, fallbackMs) {
          try {
            const durationStr = this.getCssVariableValue(propertyName, "");
            if (durationStr) {
              const match = durationStr.match(/^(\d*\.?\d+)(m?s)?$/i);
              if (match) {
                const value = parseFloat(match[1]);
                const unit = match[2]?.toLowerCase();
                if (unit === "s") return value * 1000;
                if (unit === "ms" || !unit) return value;
              }
            }
          } catch (e) {
            console.warn(`Could not parse CSS variable ${propertyName} as duration:`, e);
          }
          return fallbackMs;
        }

        /**
         * Gets a numeric value from CSS Custom Property or uses fallback.
         * @param {string} propertyName - The CSS custom property name.
         * @param {number} fallbackNumber - The fallback number.
         * @returns {number} The number.
         */
        getCssVariableNumber(propertyName, fallbackNumber) {
          try {
            const valueStr = this.getCssVariableValue(propertyName, "");
            if (valueStr) {
              const value = parseFloat(valueStr);
              if (!isNaN(value)) {
                return value;
              }
            }
          } catch (e) {
            console.warn(`Could not parse CSS variable ${propertyName} as number:`, e);
          }
          return fallbackNumber;
        }

        /**
         * Adds event listeners for filters, bubbles, and tooltips.
         */
        addEventListeners() {
          // Filter Controls
          this.filterControls.addEventListener("click", (event) => {
            const button = event.target.closest(".filter-button");
            if (button) this.handleModelFilterChange(button);
          });
          this.filterControls.addEventListener("keydown", (event) => {
            const button = event.target.closest(".filter-button");
            if (button && (event.key === "Enter" || event.key === " ")) {
              event.preventDefault();
              this.handleModelFilterChange(button);
            }
          });

          // Prompt Search Input
          this.promptSearchInput.addEventListener('input', this.handlePromptSearch.bind(this));
          this.promptSearchInput.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
              this.promptSearchInput.value = '';
              this.handlePromptSearch({ target: this.promptSearchInput });
              event.preventDefault();
            }
          });

          // Bubble Interactions & Tooltips
          this.appBubbles.forEach((bubbleData) => {
            const { element, link, infoButton, refinementSpan } = bubbleData;

            // Main bubble activation (click/key) for pop effect/navigation
            element.addEventListener("click", (event) => {
              if (event.target === infoButton || event.target === refinementSpan || infoButton?.contains(event.target) || refinementSpan?.contains(event.target)) {
                return; // Don't pop if clicking interactive elements inside
              }
              this.triggerPop(event, element, link);
            });
            element.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                if (document.activeElement === element || element.querySelector("a")?.contains(document.activeElement)) {
                  event.preventDefault(); // Prevent spacebar scroll
                  this.triggerPop(event, element, link);
                }
              }
            });

            // Info button (prompt tooltip)
            if (infoButton) {
              this.addTooltipListeners(infoButton);
              infoButton.addEventListener("click", (e) => e.stopPropagation());
              infoButton.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                  e.stopPropagation();
                  this.showTooltip(infoButton); // Explicitly show on activate
                }
              });
            }

            // Refinement span (refinement tooltip)
            if (refinementSpan) {
              this.addTooltipListeners(refinementSpan);
              refinementSpan.addEventListener("click", (e) => e.stopPropagation());
              refinementSpan.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                  e.preventDefault();
                  e.stopPropagation();
                  this.showTooltip(refinementSpan); // Ensure show on activate
                }
              });
            }
          });

          // Tooltip interaction (keep open on hover)
          this.tooltipElement.addEventListener("mouseenter", () => clearTimeout(this.hideTooltipTimeout));
          this.tooltipElement.addEventListener("mouseleave", () => this.requestHideTooltip());

          // Global listeners
          document.addEventListener("keydown", (event) => {
            if (event.key === "Escape" && this.tooltipElement.classList.contains("visible")) {
              this.hideTooltip(true); // Hide and return focus
            }
          });
          document.addEventListener("click", (event) => {
            if (this.tooltipElement.classList.contains("visible") && this.activeTooltipTrigger && !this.activeTooltipTrigger.contains(event.target) && !this.tooltipElement.contains(event.target)) {
              this.hideTooltip();
            }
          });
        }

        /**
         * Initializes ResizeObserver and scroll listener to reposition tooltip.
         */
        initPositionObserver() {
          if ("ResizeObserver" in window) {
            this.resizeObserver = new ResizeObserver(() => {
              if (this.tooltipElement.classList.contains("visible") && this.activeTooltipTrigger) {
                this.positionTooltip(this.activeTooltipTrigger);
              }
            });
          } else {
            console.warn("ResizeObserver not supported, tooltip repositioning may be limited.");
          }

          let isScrolling;
          this.scrollListener = () => {
            window.requestAnimationFrame(() => {
              if (this.tooltipElement.classList.contains("visible") && this.activeTooltipTrigger) {
                this.positionTooltip(this.activeTooltipTrigger);
              }
              isScrolling = false;
            });
          };
          window.addEventListener("scroll", this.scrollListener, { passive: true });
        }

        /**
         * Cleans up observers and listeners.
         */
        destroy() {
          if (this.resizeObserver) this.resizeObserver.disconnect();
          if (this.scrollListener) window.removeEventListener("scroll", this.scrollListener);
          clearTimeout(this.searchTimeout);
          clearTimeout(this.hideTooltipTimeout);
          // Potentially remove other listeners if needed
        }

        /**
         * Adds standard tooltip event listeners to a trigger element.
         * @param {HTMLElement} triggerElement - The element that triggers the tooltip.
         */
        addTooltipListeners(triggerElement) {
          const show = () => this.showTooltip(triggerElement);
          const hide = () => this.requestHideTooltip();
          triggerElement.addEventListener("mouseenter", show);
          triggerElement.addEventListener("focus", show);
          triggerElement.addEventListener("mouseleave", hide);
          triggerElement.addEventListener("blur", hide);
        }

        /**
         * Handles model filter button activation and triggers filtering.
         * @param {HTMLButtonElement} button - The filter button that was activated.
         */
        handleModelFilterChange(button) {
            const filterValue = button.dataset.filter;
            if (!filterValue || filterValue === this.activeModelFilter) return;
            this.activeModelFilter = filterValue;
            this.setActiveModelFilter(filterValue);
            this.filterBubbles();
            this.hideTooltip();
        }

        /**
         * Handles changes in the prompt search input field with debouncing.
         * @param {Event} event - The input event.
         */
        handlePromptSearch(event) {
            clearTimeout(this.searchTimeout);
            this.searchTimeout = setTimeout(() => {
                this.activePromptFilter = event.target.value.trim().toLowerCase();
                this.filterBubbles();
                this.hideTooltip(); // Hide tooltip when search term changes
            }, 150); // 150ms debounce
        }


        /**
         * Triggers the pop animation and navigates after a calculated delay.
         * Handles modifier keys for new tabs/windows.
         * @param {Event} event - The triggering event.
         * @param {HTMLElement} bubbleElement - The bubble article element.
         * @param {string | null} link - The destination URL.
         */
        triggerPop(event, bubbleElement, link) {
          if (!link || link === "#") {
            console.warn("Bubble link is missing or invalid.");
            event.preventDefault();
            return;
          }
          if (bubbleElement.classList.contains("popping")) return;

          const isModifierKeyPressed = event.ctrlKey || event.metaKey || event.shiftKey;
          const isMiddleClick = event.type === "click" && event.button === 1;

          // Handle new tab/window opening directly
          if (isModifierKeyPressed || isMiddleClick) {
            const target = (event.ctrlKey || event.metaKey || isMiddleClick) ? '_blank' : '_self';
            const features = event.shiftKey ? 'noopener,noreferrer' : undefined;
            window.open(link, target, features);
            event.preventDefault();
            event.stopPropagation();
            return;
          }

          // Normal activation: proceed with pop animation
          event.preventDefault();
          event.stopPropagation();
          this.hideTooltip(); // Ensure tooltip is hidden

          const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
          let navigationDelay;

          if (prefersReducedMotion) {
            navigationDelay = this.reducedMotionNavDelay;
          } else {
            navigationDelay = this.popAnimationDuration * this.popNavDelayFactor;
            // Apply fixed positioning and styles for animation
            const rect = bubbleElement.getBoundingClientRect();
            bubbleElement.style.position = "fixed";
            bubbleElement.style.top = `${rect.top}px`;
            bubbleElement.style.left = `${rect.left}px`;
            bubbleElement.style.width = `${rect.width}px`;
            bubbleElement.style.height = `${rect.height}px`;
            bubbleElement.style.zIndex = this.popZIndex;
            bubbleElement.style.margin = "0";
            void bubbleElement.offsetWidth; // Force reflow
          }

          bubbleElement.classList.add("popping");
          bubbleElement.setAttribute("aria-hidden", "true");

          // Navigate after delay
          setTimeout(() => {
            window.location.href = link;
          }, navigationDelay);
        }

        /**
         * Shows the tooltip with appropriate content, positioned near the trigger.
         * @param {HTMLElement} triggerElement - The element that triggered the tooltip.
         */
        showTooltip(triggerElement) {
          clearTimeout(this.hideTooltipTimeout); // Cancel any pending hide

          // Manage observer for position updates
          if (this.resizeObserver) {
            if (this.activeTooltipTrigger && this.activeTooltipTrigger !== triggerElement && this.activeTooltipTrigger.isConnected) {
              this.resizeObserver.unobserve(this.activeTooltipTrigger);
            }
            if ((!this.activeTooltipTrigger || this.activeTooltipTrigger !== triggerElement) && triggerElement.isConnected) {
              this.resizeObserver.observe(triggerElement);
            }
          }
          this.activeTooltipTrigger = triggerElement;

          const tooltipType = triggerElement.dataset.tooltipType || "info";
          const tooltipContent = triggerElement.dataset.tooltipContent || "No information available.";

          this.tooltipElement.textContent = tooltipContent; // Use textContent for safety
          this.tooltipElement.setAttribute("aria-hidden", "false");
          this.tooltipElement.dataset.type = tooltipType;
          this.tooltipElement.classList.add("visible");

          this.positionTooltip(triggerElement);

          // Scroll to top if tooltip content is scrollable
          this.tooltipElement.scrollTop = 0;
        }

        /**
         * Positions the tooltip relative to the trigger element, avoiding viewport edges.
         * @param {HTMLElement} triggerElement - The element the tooltip should be positioned near.
         */
        positionTooltip(triggerElement) {
          if (!this.tooltipElement.classList.contains("visible") || !triggerElement || !triggerElement.isConnected) return;

          const triggerRect = triggerElement.getBoundingClientRect();
          this.tooltipElement.style.visibility = "hidden";
          this.tooltipElement.style.display = "block";
          const tooltipHeight = this.tooltipElement.offsetHeight;
          const tooltipWidth = this.tooltipElement.offsetWidth;
          this.tooltipElement.style.display = "";
          this.tooltipElement.style.visibility = "";

          const spacing = 8;
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;

          let top = triggerRect.bottom + spacing;
          let left = triggerRect.left + triggerRect.width / 2 - tooltipWidth / 2;

          // Adjust horizontal
          if (left < spacing) left = spacing;
          else if (left + tooltipWidth > viewportWidth - spacing) left = viewportWidth - tooltipWidth - spacing;

          // Adjust vertical: Prefer below, then try above, finally cap if needed
          const spaceBelow = viewportHeight - triggerRect.bottom - spacing;
          const spaceAbove = triggerRect.top - spacing;

          if (spaceBelow < tooltipHeight && spaceAbove >= tooltipHeight) {
            // Place above
            top = triggerRect.top - tooltipHeight - spacing;
          } else if (spaceBelow < tooltipHeight && spaceAbove < tooltipHeight) {
             // Not enough space either way, place below and cap at bottom edge
             top = Math.max(spacing, viewportHeight - tooltipHeight - spacing);
          }
          // Ensure it doesn't go off the top edge
          if (top < spacing) top = spacing;

          this.tooltipElement.style.top = `${Math.round(top)}px`;
          this.tooltipElement.style.left = `${Math.round(left)}px`;
          this.tooltipElement.style.transform = ""; // Reset animation transform
        }

        /**
         * Hides the tooltip immediately.
         * @param {boolean} [returnFocus=false] - If true, attempts to return focus to the trigger element.
         */
        hideTooltip(returnFocus = false) {
          clearTimeout(this.hideTooltipTimeout);
          const triggerToFocus = this.activeTooltipTrigger;

          if (this.activeTooltipTrigger && this.resizeObserver && this.activeTooltipTrigger.isConnected) {
            this.resizeObserver.unobserve(this.activeTooltipTrigger);
          }
          this.activeTooltipTrigger = null;
          this.tooltipElement.classList.remove("visible");
          this.tooltipElement.setAttribute("aria-hidden", "true");
          this.tooltipElement.style.top = "";
          this.tooltipElement.style.left = "";
          this.tooltipElement.style.transform = "";
          delete this.tooltipElement.dataset.type;

          if (returnFocus && triggerToFocus && typeof triggerToFocus.focus === "function" && document.body.contains(triggerToFocus) && triggerToFocus.offsetParent !== null) {
            requestAnimationFrame(() => {
              if (document.body.contains(triggerToFocus) && triggerToFocus.offsetParent !== null) {
                 triggerToFocus.focus({ preventScroll: true });
              }
            });
          }
        }

        /**
         * Requests to hide the tooltip after a short delay (for hover intent).
         */
        requestHideTooltip() {
          clearTimeout(this.hideTooltipTimeout);
          this.hideTooltipTimeout = setTimeout(() => {
            const isFocusWithinTrigger = this.activeTooltipTrigger?.contains(document.activeElement);
            const isFocusWithinTooltip = this.tooltipElement.contains(document.activeElement);
            const isHoveringTooltip = this.tooltipElement.matches(":hover");
            const isHoveringTrigger = this.activeTooltipTrigger?.matches(":hover");

            if (!isFocusWithinTrigger && !isFocusWithinTooltip && !isHoveringTooltip && !isHoveringTrigger) {
              this.hideTooltip();
            }
          }, 150); // Delay for hover intent
        }

        /**
         * Sets the visual state (aria-pressed) of model filter buttons.
         * @param {string} activeFilter - The data-filter value of the active button.
         */
        setActiveModelFilter(activeFilter) {
            this.filterButtons.forEach((button) => {
                button.setAttribute("aria-pressed", String(button.dataset.filter === activeFilter));
            });
        }

        /**
         * Filters the app bubbles based on the active model and prompt filters.
         */
        filterBubbles() {
            let visibleCount = 0;
            const searchTerm = this.activePromptFilter; // Already lowercase and trimmed

            this.appBubbles.forEach((bubbleData) => {
                const { element: bubbleElement, model, prompt } = bubbleData;

                // Skip bubbles currently popping out
                if (bubbleElement.classList.contains('popping')) {
                    // Check if it *would* match if not popping, to keep count accurate
                    const wouldMatchModel = this.activeModelFilter === 'all' || model === this.activeModelFilter;
                    const wouldMatchPrompt = !searchTerm || prompt.includes(searchTerm);
                    if (wouldMatchModel && wouldMatchPrompt) {
                        visibleCount++;
                    }
                    return;
                }

                const matchesModel = this.activeModelFilter === 'all' || model === this.activeModelFilter;
                const matchesPrompt = !searchTerm || prompt.includes(searchTerm);
                const isVisible = matchesModel && matchesPrompt;

                bubbleElement.classList.toggle('hidden', !isVisible);
                bubbleElement.setAttribute('aria-hidden', String(!isVisible));
                bubbleElement.setAttribute('tabindex', isVisible ? '0' : '-1'); // Update tabindex

                if (isVisible) {
                    visibleCount++;
                }
            });

            this.emptyStateMessage.classList.toggle('visible', visibleCount === 0);

            // Optional: Announce results for screen readers (could be more robust)
            // E.g., update an aria-live region or the grid's label
             // this.bubbleGrid.setAttribute('aria-label', `Showcase displaying ${visibleCount} bubbles matching filters.`);
        }
      }

      // --- Initialize ---
      function initializeShowcase() {
        if (typeof BubbleShowcase !== "undefined") {
          window.bubbleShowcaseInstance = new BubbleShowcase();
        } else {
          console.error("BubbleShowcase class not defined.");
        }
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeShowcase);
      } else {
        initializeShowcase(); // DOM is already ready
      }
    </script>
  </body>
</html>
