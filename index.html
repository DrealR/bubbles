<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DrealR Imagineering Bubbles</title>
    <meta
      name="description"
      content="Explore unique, self-contained web experiments ('Bubbles') crafted by DrealR Imagineering using AI. Click a bubble to pop it and visit the creation!"
    />
    <style>
      :root {
        /* Core Dark Theme Palette */
        --color-background: #111827; /* Dark Blue/Gray */
        --color-text: #e5e7eb; /* Light Gray */
        --color-text-muted: #9ca3af; /* Medium Gray */
        --color-heading: #f9fafb; /* Almost White */
        --color-primary-accent: #38bdf8; /* Electric Blue */
        --color-secondary-accent: #ec4899; /* Vibrant Magenta */
        --color-focus-ring: var(--color-secondary-accent);

        /* Bubble Specific Palette */
        --color-bubble-bg-start: rgba(
          55,
          65,
          81,
          0.5
        ); /* Dark Gray semi-transparent */
        --color-bubble-bg-end: rgba(
          31,
          41,
          55,
          0.6
        ); /* Darker Gray semi-transparent */
        --color-bubble-border: rgba(
          107,
          114,
          128,
          0.3
        ); /* Subtle Gray Border */
        --color-bubble-border-hover: var(--color-primary-accent);
        --color-bubble-highlight: rgba(
          56,
          189,
          248,
          0.15
        ); /* Subtler blue highlight */
        --color-bubble-placeholder-bg-start: var(--color-primary-accent);
        --color-bubble-placeholder-bg-end: var(--color-secondary-accent);
        --color-bubble-placeholder-text: rgba(255, 255, 255, 0.85);
        --color-info-button-bg: rgba(
          17,
          24,
          39,
          0.5
        ); /* Very dark semi-transparent */
        --color-info-button-bg-hover: rgba(17, 24, 39, 0.8);
        --color-info-button-icon: var(--color-text-muted);
        --color-info-button-icon-hover: var(--color-heading);
        --color-tooltip-bg: #1f2937; /* Dark Gray 800 */
        --color-tooltip-text: var(--color-text);
        --color-tooltip-border: var(--color-bubble-border);

        /* Filter Controls Palette */
        --color-filter-bg: rgba(55, 65, 81, 0.6);
        --color-filter-text: var(--color-text);
        --color-filter-border: var(--color-bubble-border);
        --color-filter-active-bg: var(--color-primary-accent);
        --color-filter-active-text: var(--color-background);
        --color-filter-hover-bg: rgba(75, 85, 99, 0.8);

        /* Typography & Fonts */
        --font-body: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, "Helvetica Neue", Arial, sans-serif;
        --font-heading: "Poppins", var(--font-body), sans-serif; /* Optional Poppins */
        --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;

        /* Spacing */
        --spacing-xs: 0.25rem; /* 4px */
        --spacing-sm: 0.5rem; /* 8px */
        --spacing-md: 1rem; /* 16px */
        --spacing-lg: 1.5rem; /* 24px */
        --spacing-xl: 2rem; /* 32px */
        --spacing-xxl: 3rem; /* 48px */

        /* Borders & Transitions */
        --border-radius-sm: 0.375rem; /* 6px */
        --border-radius-md: 0.75rem; /* 12px */
        --border-radius-lg: 1rem; /* 16px */
        --border-radius-bubble: 50%;
        --border-radius-pill: 9999px;
        --transition-duration-fast: 0.15s;
        --transition-duration-med: 0.3s;
        --transition-timing: cubic-bezier(0.4, 0, 0.2, 1);
        --transition-timing-bounce: cubic-bezier(0.68, -0.55, 0.27, 1.55);

        /* Bubble Dimensions & Animation */
        --bubble-size: clamp(200px, 22vw, 260px); /* Adjusted size range */
        --bubble-pop-duration: 0.4s;
        --glitch-intensity: 1.5px; /* Reduced intensity */
        --tooltip-z-index: 100;
      }

      /* Optional: Load Poppins font if desired and connection available */
      /* @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap'); */

      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html {
        font-size: 100%;
        scroll-behavior: smooth;
        -webkit-text-size-adjust: 100%;
      }

      body {
        font-family: var(--font-body);
        background-color: var(--color-background);
        color: var(--color-text);
        line-height: 1.6;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow-x: hidden;
        position: relative;
      }

      /* Subtle Noise Background */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCI+DQo8ZmlsdGVyIGlkPSJub2lzZSIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSI+DQo8ZmVUdXJidWxlbmNlIHR5cGU9ImZyYWN0YWxOb2lzZSIgYmFzZUZyZXF1ZW5jeT0iMC45NSIgc3RpdGNoVGlsZXM9InN0aXRjaCIgbnVtT2N0YXZlcz0iMSIgcmVzdWx0PSJub2lzZSIvPg0KPGZlRGlmZnVzZUFtcGxpdHVkZSByZXN1bHQ9Im5vaXNlIiBpbj0ibm9pc2UiPjwvZmVEaWZmdXNlQW1wbGl0dWRlPg0KPC9maWx0ZXI+DQo8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWx0ZXI9InVybCgjbmlpZikiPjwvcmVjdD4NCjwvc3ZnPg==");
        background-repeat: repeat;
        opacity: 0.02;
        z-index: -1;
        pointer-events: none;
        animation: noise-animation 0.4s infinite linear alternate;
      }

      @keyframes noise-animation {
        0% {
          transform: translate(0, 0);
        }
        100% {
          transform: translate(1px, 1px);
        }
      }

      /* Basic Elements */
      h1,
      h2,
      h3 {
        font-family: var(--font-heading);
        color: var(--color-heading);
        line-height: 1.2;
        margin-bottom: var(--spacing-sm);
        letter-spacing: 0.02em;
        font-weight: 600;
      }

      h1 {
        font-size: clamp(2.2rem, 5vw + 1rem, 3.5rem);
        text-align: center;
        margin-bottom: var(--spacing-sm);
        font-weight: 800;
        letter-spacing: 0.04em;
        color: var(--color-heading);
        text-shadow: 0 0 5px rgba(56, 189, 248, 0.4),
          0 0 10px rgba(236, 72, 153, 0.25);
      }

      p {
        margin-bottom: var(--spacing-md);
        max-width: 70ch;
        color: var(--color-text);
      }
      p.intro-text {
        color: var(--color-text-muted);
        max-width: 65ch;
        margin: 0 auto var(--spacing-lg) auto;
        font-size: 1.05rem;
        line-height: 1.7;
      }

      a {
        color: var(--color-primary-accent);
        text-decoration: none;
        transition: color var(--transition-duration-fast)
          var(--transition-timing);
        border-radius: var(--border-radius-sm);
      }

      a:hover {
        color: var(--color-secondary-accent);
        text-decoration: underline;
        text-decoration-thickness: 1.5px;
        text-underline-offset: 4px;
      }

      a:focus {
        outline: none;
      }
      a:focus-visible {
        outline: 2px solid var(--color-focus-ring);
        outline-offset: 3px;
        color: var(--color-secondary-accent);
      }

      /* Layout Containers */
      .container {
        width: 90%;
        max-width: 1280px;
        margin-left: auto;
        margin-right: auto;
        padding-top: var(--spacing-xl);
        padding-bottom: var(--spacing-xl);
      }

      header {
        padding-top: var(--spacing-xl);
        padding-bottom: var(--spacing-lg);
        text-align: center;
        border-bottom: 1px solid var(--color-bubble-border);
        margin-bottom: var(--spacing-lg);
      }

      main {
        flex-grow: 1;
      }

      .bubble-showcase-wrapper {
        /* Added wrapper for potential future layout needs */
      }

      .bubble-showcase {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: var(--spacing-xl) var(--spacing-lg); /* Row gap, Column gap */
        padding: var(--spacing-lg) 0;
      }

      footer {
        text-align: center;
        padding: var(--spacing-lg) 0;
        margin-top: var(--spacing-xxl);
        border-top: 1px solid var(--color-bubble-border);
        color: var(--color-text-muted);
        font-size: 0.9rem;
      }

      /* Filter Controls */
      .filter-controls {
        margin-bottom: var(--spacing-xl);
        padding: var(--spacing-md);
        background-color: var(--color-filter-bg);
        border: 1px solid var(--color-filter-border);
        border-radius: var(--border-radius-md);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        display: flex;
        flex-wrap: wrap;
        gap: var(--spacing-sm) var(--spacing-md); /* Row gap, Column gap */
        justify-content: center;
        align-items: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .filter-controls .filter-label {
        font-weight: 600;
        color: var(--color-text);
        margin-right: var(--spacing-sm); /* Reduced margin */
        flex-shrink: 0;
      }

      .filter-controls .filter-button {
        padding: var(--spacing-xs) var(--spacing-md);
        font-size: 0.9rem;
        font-weight: 500;
        border: 1px solid var(--color-filter-border);
        border-radius: var(--border-radius-pill);
        background-color: transparent;
        color: var(--color-filter-text);
        cursor: pointer;
        transition: background-color var(--transition-duration-fast)
            var(--transition-timing),
          color var(--transition-duration-fast) var(--transition-timing),
          border-color var(--transition-duration-fast) var(--transition-timing),
          transform var(--transition-duration-fast) var(--transition-timing);
        user-select: none;
        appearance: none;
      }

      .filter-controls .filter-button:hover {
        background-color: var(--color-filter-hover-bg);
        border-color: var(--color-primary-accent);
        transform: translateY(-2px);
        color: var(--color-heading);
      }

      .filter-controls .filter-button:focus {
        outline: none;
      }
      .filter-controls .filter-button:focus-visible {
        outline: 2px solid var(--color-focus-ring);
        outline-offset: 2px;
        border-color: var(--color-focus-ring);
      }

      .filter-controls .filter-button[aria-pressed="true"] {
        background-color: var(--color-filter-active-bg);
        color: var(--color-filter-active-text);
        border-color: var(--color-filter-active-bg);
        font-weight: 600;
      }

      /* Bubble Styling */
      .app-bubble {
        width: var(--bubble-size);
        height: var(--bubble-size);
        border-radius: var(--border-radius-bubble);
        background: linear-gradient(
          135deg,
          var(--color-bubble-bg-start),
          var(--color-bubble-bg-end)
        );
        border: 1px solid var(--color-bubble-border);
        position: relative;
        overflow: visible; /* Allow info button/tooltip potentially outside */
        display: flex; /* Container for link content */
        cursor: pointer;
        transition: transform var(--transition-duration-med)
            var(--transition-timing),
          box-shadow var(--transition-duration-med) var(--transition-timing),
          border-color var(--transition-duration-med) var(--transition-timing),
          opacity var(--transition-duration-med) var(--transition-timing),
          visibility var(--transition-duration-med) linear;
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25),
          inset 0 1px 3px rgba(255, 255, 255, 0.05);
        will-change: transform, opacity;
        outline: none; /* Focus handled by focus-visible */
      }

      .app-bubble:hover,
      .app-bubble:focus-visible {
        transform: translateY(-6px) scale(1.04);
        border-color: var(--color-bubble-border-hover);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35),
          inset 0 1px 4px rgba(255, 255, 255, 0.08);
      }
      .app-bubble:focus-visible {
        outline: 3px solid var(--color-focus-ring);
        outline-offset: 5px;
      }

      /* Bubble highlight effect */
      .app-bubble::before {
        content: "";
        position: absolute;
        top: 8%;
        left: 15%;
        width: 60%;
        height: 30%;
        background: radial-gradient(
          ellipse at center,
          var(--color-bubble-highlight) 0%,
          transparent 70%
        );
        border-radius: 50%;
        opacity: 0.6;
        transform: rotate(-25deg);
        pointer-events: none;
        transition: opacity var(--transition-duration-med) ease,
          transform var(--transition-duration-med) ease;
        filter: blur(8px);
        z-index: 1; /* Above background, below content */
      }
      .app-bubble:hover::before {
        opacity: 0.8;
        transform: rotate(-20deg) scale(1.1);
      }

      /* Glitchy border effect */
      .app-bubble::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 1.5px solid var(--color-secondary-accent);
        border-radius: inherit;
        opacity: 0;
        transition: opacity var(--transition-duration-med) ease-in-out,
          transform var(--transition-duration-med) ease-in-out;
        pointer-events: none;
        z-index: 0;
        transform: translate(0, 0);
      }
      .app-bubble:hover::after,
      .app-bubble:focus-within::after {
        /* Trigger on focus within */
        opacity: 0.35; /* Slightly reduced opacity */
        animation: bubble-glitch 0.6s infinite alternate linear; /* Slightly slower */
      }

      @keyframes bubble-glitch {
        0% {
          transform: translate(
            var(--glitch-intensity),
            calc(var(--glitch-intensity) * -1)
          );
          clip-path: polygon(0% 0%, 100% 0%, 100% 45%, 0% 55%);
        }
        100% {
          transform: translate(
            calc(var(--glitch-intensity) * -1),
            var(--glitch-intensity)
          );
          clip-path: polygon(0% 55%, 100% 45%, 100% 100%, 0% 100%);
        }
      }

      /* Filtered out state */
      .app-bubble.hidden {
        opacity: 0;
        transform: scale(0.8);
        pointer-events: none;
        visibility: hidden;
        transition: opacity var(--transition-duration-med)
            var(--transition-timing),
          transform var(--transition-duration-med) var(--transition-timing),
          visibility 0s linear var(--transition-duration-med),
          width 0s linear var(--transition-duration-med),
          /* Immediate collapse */ height 0s linear
            var(--transition-duration-med),
          padding 0s linear var(--transition-duration-med),
          margin 0s linear var(--transition-duration-med),
          border 0s linear var(--transition-duration-med),
          gap 0s linear var(--transition-duration-med);

        /* Collapse the space */
        width: 0 !important;
        height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
        border: none !important;
        overflow: hidden !important;
        gap: 0 !important; /* Reset gap contribution */
      }

      .bubble-link-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        padding: var(--spacing-sm);
        color: var(--color-heading);
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        text-align: center;
        position: relative;
        z-index: 2; /* Above pseudo-elements */
        text-decoration: none; /* Ensure no underline */
        border-radius: inherit; /* Make link area match bubble shape */
        outline: none; /* Remove focus outline from link itself */
      }

      .bubble-image-placeholder {
        width: 35%;
        aspect-ratio: 1 / 1; /* Maintain square */
        height: auto; /* Let aspect-ratio define height */
        border-radius: 50%;
        background: linear-gradient(
          45deg,
          var(--color-bubble-placeholder-bg-start),
          var(--color-bubble-placeholder-bg-end)
        );
        opacity: 0.65; /* Slightly more opaque */
        margin-bottom: var(--spacing-sm);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.6rem;
        color: var(--color-bubble-placeholder-text);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3),
          0 2px 5px rgba(0, 0, 0, 0.2);
        flex-shrink: 0;
      }

      .app-bubble h3 {
        font-size: clamp(0.9rem, 1.5vw + 0.5rem, 1.15rem);
        font-weight: 600;
        margin-bottom: var(--spacing-xs);
        color: var(--color-heading);
        max-width: 90%; /* Prevent title touching edges/info button */
        line-height: 1.3;
        overflow-wrap: break-word; /* Break long words if needed */
      }

      .app-bubble .model-name {
        font-size: 0.75rem;
        color: var(--color-text-muted);
        font-weight: 400;
        display: block;
        margin-top: var(--spacing-xs);
        line-height: 1.3;
      }

      /* Refinements Info */
      .app-bubble .generation-refinements {
        font-size: 0.7rem;
        color: var(--color-text-muted);
        font-weight: 400;
        display: block;
        margin-top: var(--spacing-sm);
        opacity: 0.8;
        cursor: help; /* Indicate interaction */
        text-decoration: underline dashed 1px;
        text-decoration-color: rgba(156, 163, 175, 0.5);
        text-underline-offset: 2px;
        transition: color var(--transition-duration-fast),
          text-decoration-color var(--transition-duration-fast),
          opacity var(--transition-duration-fast);
        border-radius: var(--border-radius-sm);
        padding: var(--spacing-xs);
        margin: var(--spacing-sm) calc(var(--spacing-xs) * -1) 0; /* Adjust margin for padding */
        line-height: 1.3;
        max-width: calc(
          100% - 50px
        ); /* Prevent overlap with info button more reliably */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        outline: none; /* Focus handled by focus-visible */
      }

      .app-bubble .generation-refinements:hover,
      .app-bubble .generation-refinements:focus {
        color: var(--color-text);
        opacity: 1;
        text-decoration-color: var(--color-primary-accent);
      }
      .app-bubble .generation-refinements:focus-visible {
        outline: 2px solid var(--color-focus-ring);
        outline-offset: 1px;
        opacity: 1; /* Ensure visibility on focus */
      }

      /* Info Button */
      .info-button {
        position: absolute;
        top: var(--spacing-md);
        right: var(--spacing-md);
        z-index: 3; /* Above content, below tooltip */
        padding: 0; /* Padding handled by size */
        margin: 0;
        background-color: var(--color-info-button-bg);
        border: 1px solid var(--color-bubble-border);
        border-radius: 50%;
        cursor: help;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        color: var(--color-info-button-icon);
        opacity: 0; /* Hidden by default */
        transform: scale(0.8);
        transition: opacity var(--transition-duration-fast) ease-in-out,
          transform var(--transition-duration-fast) ease-in-out,
          background-color var(--transition-duration-fast) ease-in-out,
          color var(--transition-duration-fast) ease-in-out;
        backdrop-filter: blur(3px);
        -webkit-backdrop-filter: blur(3px);
        appearance: none;
        outline: none; /* Focus handled by focus-visible */
      }
      .app-bubble:hover .info-button,
        .app-bubble:focus-within .info-button,
        .info-button:focus-visible /* Keep visible when focused itself */ {
        opacity: 1;
        transform: scale(1);
      }

      .info-button svg {
        width: 16px;
        height: 16px;
        display: block;
      }

      .info-button:hover,
      .info-button:focus {
        background-color: var(--color-info-button-bg-hover);
        color: var(--color-info-button-icon-hover);
        border-color: var(--color-primary-accent);
        transform: scale(1.1); /* Slightly larger on hover/focus */
      }
      .info-button:focus-visible {
        outline: 2px solid var(--color-focus-ring);
        outline-offset: 2px;
        transform: scale(1.1); /* Maintain scale on focus */
      }

      /* Unified Tooltip Styling */
      #bubble-tooltip {
        position: fixed; /* Relative to viewport */
        z-index: var(--tooltip-z-index);
        background-color: var(--color-tooltip-bg);
        color: var(--color-tooltip-text);
        border: 1px solid var(--color-tooltip-border);
        border-radius: var(--border-radius-md);
        padding: var(--spacing-md);
        font-size: 0.85rem;
        line-height: 1.5;
        max-width: 350px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: translateY(10px) scale(0.95);
        transition: opacity var(--transition-duration-fast)
            var(--transition-timing),
          visibility 0s linear var(--transition-duration-fast),
          transform var(--transition-duration-fast) var(--transition-timing);
        white-space: pre-wrap;
        word-wrap: break-word;
        font-family: var(--font-body);
      }

      #bubble-tooltip[data-type="prompt"] {
        font-family: var(--font-mono);
        max-width: 400px;
      }
      #bubble-tooltip[data-type="refinement"] {
        max-width: 300px;
      }

      #bubble-tooltip.visible {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateY(0) scale(1);
        transition-delay: 0s, 0s, 0s; /* Reset delays */
      }
      #bubble-tooltip code {
        background-color: rgba(0, 0, 0, 0.2);
        padding: 0.1em 0.3em;
        border-radius: var(--border-radius-sm);
        font-size: 0.9em;
        word-break: break-all; /* Force break very long code words */
      }

      /* Pop Animation */
      .app-bubble.popping {
        animation: pop var(--bubble-pop-duration)
          var(--transition-timing-bounce) forwards;
        cursor: default;
        pointer-events: none;
        z-index: 5;
      }

      @keyframes pop {
        0% {
          transform: scale(1.04);
          opacity: 1;
          filter: blur(0px);
        }
        50% {
          transform: scale(1.3);
          opacity: 0.7;
          filter: blur(3px);
        }
        100% {
          transform: scale(0);
          opacity: 0;
          filter: blur(15px);
        }
      }

      /* Empty state message */
      .empty-state {
        text-align: center;
        color: var(--color-text-muted);
        padding: var(--spacing-xl);
        border: 2px dashed var(--color-bubble-border);
        border-radius: var(--border-radius-md);
        width: calc(100% - var(--spacing-lg) * 2);
        margin: var(--spacing-lg) auto;
        display: none; /* Hidden by default */
      }
      .empty-state.visible {
        display: block;
      }

      /* Accessibility */
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
      }

      /* Media Queries */
      @media (max-width: 768px) {
        h1 {
          font-size: clamp(2rem, 8vw, 3rem);
        }
        .container {
          width: 95%;
        }
        .bubble-showcase {
          gap: var(--spacing-lg);
        }
        .filter-controls {
          flex-direction: column;
          align-items: stretch;
          text-align: center;
        }
        .filter-controls .filter-label {
          margin-right: 0;
          margin-bottom: var(--spacing-sm);
        }
        .info-button {
          top: var(--spacing-sm);
          right: var(--spacing-sm);
          width: 24px;
          height: 24px;
        }
        .info-button svg {
          width: 14px;
          height: 14px;
        }
        #bubble-tooltip {
          max-width: 90vw;
          font-size: 0.8rem;
        }
        #bubble-tooltip[data-type="prompt"],
        #bubble-tooltip[data-type="refinement"] {
          max-width: 90vw;
        }
      }

      @media (max-width: 480px) {
        p.intro-text {
          font-size: 1rem;
        }
        .app-bubble h3 {
          font-size: 0.85rem;
        }
        .app-bubble .model-name {
          font-size: 0.7rem;
        }
        .app-bubble .generation-refinements {
          font-size: 0.65rem;
          max-width: calc(100% - 40px);
        }
        .bubble-image-placeholder {
          width: 30%;
        }
        .filter-controls .filter-button {
          font-size: 0.85rem;
          padding: var(--spacing-xs) var(--spacing-sm);
        }
      }

      @media (prefers-reduced-motion: reduce) {
        body::before,
        .app-bubble::after,
        .app-bubble.popping {
          animation: none !important;
        }
        .app-bubble,
        .filter-button,
        .app-bubble::before,
        .app-bubble::after,
        .info-button,
        #bubble-tooltip,
        .generation-refinements {
          transition-duration: 0.01ms !important;
          transition-delay: 0ms !important;
        }
        .app-bubble.popping {
          opacity: 0;
          transform: scale(0);
        }
        .app-bubble:hover,
        .app-bubble:focus-visible,
        .app-bubble:focus-within {
          transform: none;
        }
        .app-bubble:hover::before {
          transform: rotate(-25deg);
        }
        .info-button {
          transform: scale(1);
        }
        .info-button:hover,
        .info-button:focus {
          transform: scale(1);
        }
        #bubble-tooltip {
          transform: translateY(0) scale(1);
        }
        .filter-button:hover {
          transform: none;
        }
      }
    </style>
  </head>
  <body>
    <header class="container">
      <h1>DrealR Imagineering Bubbles</h1>
      <p class="intro-text">
        Welcome! These self-contained web experiences, or 'Bubbles', are simple
        HTML files – each a unique digital creation. Planted by a human prompt,
        they are grown and refined collaboratively with AI assistants. Click a
        bubble to pop it and explore! Use the
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 20 20"
          fill="currentColor"
          style="
            width: 1em;
            height: 1em;
            vertical-align: -0.125em;
            display: inline-block;
            color: var(--color-info-button-icon);
          "
          aria-hidden="true"
        >
          <path
            fill-rule="evenodd"
            d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
            clip-rule="evenodd"
          />
        </svg>
        icon for initial prompts and hover over or focus "Refinements" for
        iteration details.
      </p>

      <div
        class="filter-controls"
        role="toolbar"
        aria-label="Filter apps by AI Model"
      >
        <span class="filter-label" id="filter-label">Filter by Model:</span>
        <button
          type="button"
          class="filter-button"
          data-filter="all"
          aria-pressed="true"
          aria-describedby="filter-label"
        >
          All
        </button>
        <button
          type="button"
          class="filter-button"
          data-filter="gemini-2.5-pro"
          aria-pressed="false"
          aria-describedby="filter-label"
        >
          Gemini 2.5 Pro
        </button>
        <button
          type="button"
          class="filter-button"
          data-filter="claude-3.7-thinking"
          aria-pressed="false"
          aria-describedby="filter-label"
        >
          Claude 3.7 thinking
        </button>
        <button
          type="button"
          class="filter-button"
          data-filter="nightwhisper"
          aria-pressed="false"
          aria-describedby="filter-label"
        >
          Nightwhisper
        </button>
        <!-- Add more filter buttons here as needed -->
      </div>
    </header>

    <main class="container">
      <section
        class="bubble-showcase-wrapper"
        aria-labelledby="showcase-heading"
      >
        <h2 id="showcase-heading" class="sr-only">App Bubble Showcase</h2>
        <div
          class="bubble-showcase"
          id="bubble-grid"
          aria-live="polite"
          aria-atomic="true"
        >
          <!-- Announce changes when filters are applied -->

          <!-- Bubble 1: Pokémon Battle Simulator -->
          <article
            class="app-bubble"
            data-model="gemini-2.5-pro"
            tabindex="0"
            aria-labelledby="gemini-app1-title"
          >
            <a
              href="pokemon-sim-gemini.html"
              class="bubble-link-content"
              tabindex="-1"
              aria-hidden="true"
            >
              <!-- Link content, not directly focusable -->
              <div class="bubble-image-placeholder" aria-hidden="true">IMG</div>
              <h3 id="gemini-app1-title">Pokémon Battle Simulator</h3>
              <span class="model-name">Gemini 2.5 Pro</span>
              <span
                class="generation-refinements"
                tabindex="0"
                aria-describedby="bubble-tooltip"
                data-tooltip-type="refinement"
                data-tooltip-content="Developed over 3 refinement iterations with the AI."
                >Refinements: 3</span
              >
            </a>
            <button
              type="button"
              class="info-button"
              aria-label="View Prompt for Pokémon Battle Simulator"
              aria-describedby="bubble-tooltip"
              data-tooltip-type="prompt"
              data-tooltip-content="Initial prompt: Create a turn-based Pokémon battle simulator in a single HTML file using vanilla JS/CSS. Include basic attack logic, HP display, and simple UI elements. Focus on core mechanics and expandability."
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 20 20"
                fill="currentColor"
                aria-hidden="true"
              >
                <path
                  fill-rule="evenodd"
                  d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                  clip-rule="evenodd"
                />
              </svg>
            </button>
            <span class="sr-only"
              >(Opens Pokémon Battle Simulator generated by Gemini 2.5
              Pro)</span
            >
          </article>

          <!-- Bubble 2: Pokémon Catch Game -->
          <article
            class="app-bubble"
            data-model="claude-3.7-thinking"
            tabindex="0"
            aria-labelledby="claude-app1-title"
          >
            <a
              href="poke-catch-sonnet.html"
              class="bubble-link-content"
              tabindex="-1"
              aria-hidden="true"
            >
              <div class="bubble-image-placeholder" aria-hidden="true">IMG</div>
              <h3 id="claude-app1-title">Pokémon Catch Game</h3>
              <span class="model-name">Claude 3.7 thinking</span>
              <span
                class="generation-refinements"
                tabindex="0"
                aria-describedby="bubble-tooltip"
                data-tooltip-type="refinement"
                data-tooltip-content="Developed over 1 refinement iteration with the AI."
                >Refinements: 0</span
              >
            </a>
            <button
              type="button"
              class="info-button"
              aria-label="View Prompt for Pokémon Catch Game"
              aria-describedby="bubble-tooltip"
              data-tooltip-type="prompt"
              data-tooltip-content="Initial prompt: Design a simple game mechanic for catching Pokémon within a single HTML file. Use basic JavaScript for interaction (e.g., clicking at the right time) and CSS for visual feedback."
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 20 20"
                fill="currentColor"
                aria-hidden="true"
              >
                <path
                  fill-rule="evenodd"
                  d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                  clip-rule="evenodd"
                />
              </svg>
            </button>
            <span class="sr-only"
              >(Opens Pokémon Catch Game generated by Claude 3.7 thinking)</span
            >
          </article>

          <!-- Bubble 3: Pokémon Battle Arena -->
          <article
            class="app-bubble"
            data-model="nightwhisper"
            tabindex="0"
            aria-labelledby="nightwhisper-app1-title"
          >
            <a
              href="pokemon-sim-nightwhisper.html"
              class="bubble-link-content"
              tabindex="-1"
              aria-hidden="true"
            >
              <div class="bubble-image-placeholder" aria-hidden="true">IMG</div>
              <h3 id="nightwhisper-app1-title">Pokémon Battle Arena</h3>
              <span class="model-name">Nightwhisper</span>
              <span
                class="generation-refinements"
                tabindex="0"
                aria-describedby="bubble-tooltip"
                data-tooltip-type="refinement"
                data-tooltip-content="Developed over 1 refinement iteration with the AI."
                >Refinements: 0</span
              >
            </a>
            <button
              type="button"
              class="info-button"
              aria-label="View Prompt for Pokémon Battle Arena"
              aria-describedby="bubble-tooltip"
              data-tooltip-type="prompt"
              data-tooltip-content="Initial prompt: Build an enhanced Pokémon battle interface in a single HTML file. Focus on visual presentation using CSS, potentially incorporating simple animations or dynamic layout adjustments during battle sequences."
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 20 20"
                fill="currentColor"
                aria-hidden="true"
              >
                <path
                  fill-rule="evenodd"
                  d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                  clip-rule="evenodd"
                />
              </svg>
            </button>
            <span class="sr-only"
              >(Opens Pokémon Battle Arena generated by Nightwhisper)</span
            >
          </article>

          <!-- Add more app bubbles here, following the pattern -->
          <!-- Ensure unique IDs for titles (e.g., id="model-appN-title") -->
          <!-- Update href, data-model -->
          <!-- Update h3, model-name, Refinements text & tooltip -->
          <!-- Update button aria-label and prompt tooltip content -->
        </div>
        <div class="empty-state" id="empty-state-message">
          <p>No bubbles match the selected filter. Try another one!</p>
        </div>
      </section>
    </main>

    <footer>
      <div class="container">
        <p>© DrealR Imagineering</p>
      </div>
    </footer>

    <!-- Single Unified Tooltip Element -->
    <div id="bubble-tooltip" role="tooltip" aria-hidden="true"></div>

    <script>
      /**
       * @typedef {Object} AppBubbleData
       * @property {HTMLElement} element - The bubble's main HTML element (<article>).
       * @property {string} model - The AI model associated with the bubble.
       * @property {string | null} link - The destination URL for the bubble.
       * @property {HTMLButtonElement | null} infoButton - The info button element.
       * @property {HTMLElement | null} refinementSpan - The refinement info span element.
       */

      /**
       * Manages the filtering, interaction, and tooltips of AI-generated app bubbles.
       */
      class BubbleShowcase {
        /**
         * Initializes the bubble showcase functionality.
         */
        constructor() {
          this.filterControls = document.querySelector(".filter-controls");
          this.bubbleGrid = document.getElementById("bubble-grid");
          this.emptyStateMessage = document.getElementById(
            "empty-state-message"
          );
          this.tooltipElement = document.getElementById("bubble-tooltip");

          if (
            !this.filterControls ||
            !this.bubbleGrid ||
            !this.emptyStateMessage ||
            !this.tooltipElement
          ) {
            console.error(
              "Bubble Showcase Error: Required elements missing (controls, grid, empty state, or tooltip)."
            );
            return;
          }

          /** @type {AppBubbleData[]} */
          this.appBubbles = [];
          this.initBubbles(); // Populate appBubbles array

          this.filterButtons =
            this.filterControls.querySelectorAll(".filter-button");
          this.popAnimationDuration = this.getCssVariableDuration(
            "--bubble-pop-duration",
            400
          );
          /** @type {HTMLElement | null} */
          this.activeTooltipTrigger = null; // Track which element triggered the tooltip
          /** @type {number | null} */
          this.hideTooltipTimeout = null; // Timeout reference for delayed hiding
          /** @type {ResizeObserver | null} */
          this.resizeObserver = null; // For repositioning tooltip on resize/scroll
          /** @type {Function | null} */
          this.scrollListener = null; // Reference to the scroll listener

          this.addEventListeners();
          this.filterBubbles("all"); // Apply initial filter ('all' is default active)
          this.initPositionObserver(); // Initialize observer for tooltip repositioning
          // console.log("DrealR Imagineering Bubble Showcase Initialized.");
        }

        /**
         * Parses bubble elements from the DOM and populates the this.appBubbles array.
         */
        initBubbles() {
          this.appBubbles = Array.from(
            this.bubbleGrid.querySelectorAll(".app-bubble")
          ).map((bubbleEl) => {
            const linkContent = bubbleEl.querySelector("a.bubble-link-content");
            const infoButton = bubbleEl.querySelector(".info-button");
            const refinementSpan = bubbleEl.querySelector(
              ".generation-refinements"
            );
            return {
              element: bubbleEl,
              model: bubbleEl.dataset.model || "unknown",
              link: linkContent?.getAttribute("href"), // Get link from <a> href
              infoButton: infoButton,
              refinementSpan: refinementSpan,
            };
          });
        }

        /**
         * Gets animation duration from CSS Custom Property or uses fallback.
         * @param {string} propertyName - The CSS custom property name.
         * @param {number} fallbackMs - The fallback duration in milliseconds.
         * @returns {number} Duration in milliseconds.
         */
        getCssVariableDuration(propertyName, fallbackMs) {
          try {
            const durationStr = getComputedStyle(
              document.documentElement
            ).getPropertyValue(propertyName);
            if (durationStr) {
              const match = durationStr.trim().match(/^(\d*\.?\d+)(m?s)?$/i);
              if (match) {
                const value = parseFloat(match[1]);
                const unit = match[2]?.toLowerCase();
                if (unit === "s") return value * 1000;
                if (unit === "ms" || !unit) return value;
              }
            }
          } catch (e) {
            console.warn(`Could not parse CSS variable ${propertyName}:`, e);
          }
          return fallbackMs;
        }

        /**
         * Adds event listeners for filters, bubbles, and tooltips.
         */
        addEventListeners() {
          // --- Filter Controls ---
          this.filterControls.addEventListener("click", (event) => {
            const button = event.target.closest(".filter-button");
            if (button) {
              this.handleFilterChange(button);
            }
          });
          this.filterControls.addEventListener("keydown", (event) => {
            const button = event.target.closest(".filter-button");
            if (button && (event.key === "Enter" || event.key === " ")) {
              event.preventDefault();
              this.handleFilterChange(button);
            }
          });

          // --- Bubble Interactions & Tooltips ---
          this.appBubbles.forEach((bubbleData) => {
            const { element, link, infoButton, refinementSpan } = bubbleData;

            // Main bubble activation (click or keypress) for navigation (pop effect)
            element.addEventListener("click", (event) => {
              // Prevent pop if click is on interactive inner elements
              if (
                event.target === infoButton ||
                event.target === refinementSpan ||
                infoButton?.contains(event.target) ||
                refinementSpan?.contains(event.target)
              ) {
                return;
              }
              this.triggerPop(event, element, link);
            });
            element.addEventListener("keydown", (event) => {
              // Allow triggering pop via Enter/Space on the parent bubble article
              // We don't need to check for inner controls here because keydown bubbles
              // and the interactive elements will handle their own keydown events first
              // (and potentially stop propagation if needed).
              if (event.key === "Enter" || event.key === " ") {
                // Check if focus is *directly* on the article itself
                // or if it bubbled from the link (which we allow)
                if (
                  document.activeElement === element ||
                  element.querySelector("a")?.contains(document.activeElement)
                ) {
                  this.triggerPop(event, element, link);
                }
              }
            });

            // Info button listeners (prompt tooltip)
            if (infoButton) {
              this.addTooltipListeners(infoButton);
              // Prevent bubble pop when clicking/activating info button
              infoButton.addEventListener("click", (event) =>
                event.stopPropagation()
              );
              infoButton.addEventListener("keydown", (event) => {
                if (event.key === "Enter" || event.key === " ") {
                  event.stopPropagation(); // Prevent triggering bubble pop
                  this.showTooltip(infoButton); // Explicitly show tooltip on activate
                }
              });
            }

            // Refinement span listeners (refinement tooltip)
            if (refinementSpan) {
              this.addTooltipListeners(refinementSpan);
              // Prevent bubble pop when clicking/activating refinement span
              refinementSpan.addEventListener("click", (event) =>
                event.stopPropagation()
              );
              refinementSpan.addEventListener("keydown", (event) => {
                if (event.key === "Enter" || event.key === " ") {
                  event.preventDefault(); // Prevent potential scroll
                  event.stopPropagation(); // Prevent triggering bubble pop
                  this.showTooltip(refinementSpan); // Ensure tooltip shows on activation
                }
              });
            }
          });

          // Tooltip listeners (to keep it open when hovering over it)
          this.tooltipElement.addEventListener("mouseenter", () =>
            clearTimeout(this.hideTooltipTimeout)
          );
          this.tooltipElement.addEventListener("mouseleave", () =>
            this.requestHideTooltip()
          );

          // Global listeners
          document.addEventListener("keydown", (event) => {
            if (
              event.key === "Escape" &&
              this.tooltipElement.classList.contains("visible")
            ) {
              this.hideTooltip(true); // Hide and return focus
            }
          });
          // Optional: Hide tooltip if user clicks outside the trigger/tooltip
          document.addEventListener("click", (event) => {
            if (
              this.tooltipElement.classList.contains("visible") &&
              this.activeTooltipTrigger &&
              !this.activeTooltipTrigger.contains(event.target) &&
              !this.tooltipElement.contains(event.target)
            ) {
              this.hideTooltip();
            }
          });
        }

        /**
         * Initializes ResizeObserver and scroll listener to reposition tooltip.
         */
        initPositionObserver() {
          // Use ResizeObserver for element resize/movements
          if ("ResizeObserver" in window) {
            this.resizeObserver = new ResizeObserver(() => {
              if (
                this.tooltipElement.classList.contains("visible") &&
                this.activeTooltipTrigger
              ) {
                this.positionTooltip(this.activeTooltipTrigger);
              }
            });
          } else {
            console.warn(
              "ResizeObserver not supported, tooltip repositioning on resize may be limited."
            );
          }

          // Use a throttled scroll listener for page scroll repositioning
          let isScrolling;
          this.scrollListener = () => {
            if (!isScrolling) {
              window.requestAnimationFrame(() => {
                if (
                  this.tooltipElement.classList.contains("visible") &&
                  this.activeTooltipTrigger
                ) {
                  this.positionTooltip(this.activeTooltipTrigger);
                }
                isScrolling = false;
              });
              isScrolling = true;
            }
          };
          window.addEventListener("scroll", this.scrollListener, {
            passive: true,
          });
        }

        /**
         * Cleans up observers and listeners.
         */
        destroy() {
          if (this.resizeObserver) {
            this.resizeObserver.disconnect();
          }
          if (this.scrollListener) {
            window.removeEventListener("scroll", this.scrollListener);
          }
          // Potentially remove other listeners if needed, though usually not necessary for a page script like this
          // unless you're re-initializing frequently without page reloads.
        }

        /**
         * Adds standard tooltip event listeners to a trigger element.
         * @param {HTMLElement} triggerElement - The element that triggers the tooltip.
         */
        addTooltipListeners(triggerElement) {
          const show = () => this.showTooltip(triggerElement);
          const hide = () => this.requestHideTooltip();

          triggerElement.addEventListener("mouseenter", show);
          triggerElement.addEventListener("focus", show);
          triggerElement.addEventListener("mouseleave", hide);
          triggerElement.addEventListener("blur", hide);
        }

        /**
         * Handles filter button activation and triggers filtering.
         * @param {HTMLButtonElement} button - The filter button that was activated.
         */
        handleFilterChange(button) {
          const filterValue = button.dataset.filter;
          if (!filterValue) return;
          this.setActiveFilter(filterValue);
          this.filterBubbles(filterValue);
          this.hideTooltip(); // Hide tooltip when filtering changes
        }

        /**
         * Triggers the pop animation and navigates after delay.
         * @param {Event} event - The triggering event.
         * @param {HTMLElement} bubbleElement - The bubble article element.
         * @param {string | null} link - The destination URL.
         */
        triggerPop(event, bubbleElement, link) {
          if (!link || link === "#") {
            console.warn("Bubble link is missing or invalid. Cannot navigate.");
            event.preventDefault(); // Prevent default if it's somehow still an anchor
            return;
          }
          if (bubbleElement.classList.contains("popping")) return; // Prevent double pop

          // Check for modifier keys (allow opening in new tab)
          const isModifierKeyPressed =
            event.ctrlKey || event.metaKey || event.shiftKey;
          // Check for middle mouse button click
          const isMiddleClick = event.type === "click" && event.button === 1;

          // If modifier key or middle click, don't animate, let browser handle default action (new tab/window)
          if (isModifierKeyPressed || isMiddleClick) {
            // We might need to temporarily make the inner link clickable again
            const innerLink = bubbleElement.querySelector(
              "a.bubble-link-content"
            );
            if (innerLink && innerLink.href) {
              // Since the main click is on the article, we simulate the link click
              // or directly navigate if simulation is complex/unreliable.
              // Simplest: navigate based on intention
              if (event.ctrlKey || event.metaKey || isMiddleClick) {
                // New tab
                window.open(link, "_blank");
              } else if (event.shiftKey) {
                // New window
                window.open(link, "_blank", "noopener,noreferrer"); // Consider security
              }
              event.preventDefault(); // Prevent any default action on the article/outer element
              event.stopPropagation();
              return;
            }
          }

          // Normal click/activation: proceed with pop animation
          event.preventDefault();
          event.stopPropagation();

          this.hideTooltip(); // Ensure tooltip is hidden before popping
          bubbleElement.classList.add("popping");
          bubbleElement.setAttribute("aria-hidden", "true");

          setTimeout(() => {
            window.location.href = link;
          }, this.popAnimationDuration);
        }

        /**
         * Shows the tooltip with appropriate content, positioned near the trigger.
         * @param {HTMLElement} triggerElement - The element that triggered the tooltip.
         */
        showTooltip(triggerElement) {
          clearTimeout(this.hideTooltipTimeout); // Cancel any pending hide requests

          // Manage observer
          if (this.resizeObserver) {
            if (
              this.activeTooltipTrigger &&
              this.activeTooltipTrigger !== triggerElement
            ) {
              this.resizeObserver.unobserve(this.activeTooltipTrigger);
            }
            if (
              !this.activeTooltipTrigger ||
              this.activeTooltipTrigger !== triggerElement
            ) {
              this.resizeObserver.observe(triggerElement);
            }
          }
          this.activeTooltipTrigger = triggerElement; // Track the current trigger

          const tooltipType = triggerElement.dataset.tooltipType || "info";
          const tooltipContent =
            triggerElement.dataset.tooltipContent ||
            "No information available.";

          this.tooltipElement.textContent = tooltipContent;
          this.tooltipElement.setAttribute("aria-hidden", "false");
          this.tooltipElement.dataset.type = tooltipType;
          this.tooltipElement.classList.add("visible");

          this.positionTooltip(triggerElement);
        }

        /**
         * Positions the tooltip relative to the trigger element, avoiding viewport edges.
         * @param {HTMLElement} triggerElement - The element the tooltip should be positioned near.
         */
        positionTooltip(triggerElement) {
          if (
            !this.tooltipElement.classList.contains("visible") ||
            !triggerElement
          )
            return;

          const triggerRect = triggerElement.getBoundingClientRect();
          // Force reflow to get accurate tooltip dimensions after content/class change
          this.tooltipElement.style.visibility = "hidden"; // Temporarily hide while measuring
          this.tooltipElement.style.display = "block";
          const tooltipHeight = this.tooltipElement.offsetHeight;
          const tooltipWidth = this.tooltipElement.offsetWidth;
          this.tooltipElement.style.display = ""; // Reset display
          this.tooltipElement.style.visibility = ""; // Make visible again

          const spacing = 8;
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;

          // Default position: below and centered horizontally
          let top = triggerRect.bottom + spacing;
          let left =
            triggerRect.left + triggerRect.width / 2 - tooltipWidth / 2;

          // Adjust horizontal position
          if (left < spacing) {
            left = spacing;
          } else if (left + tooltipWidth > viewportWidth - spacing) {
            left = viewportWidth - tooltipWidth - spacing;
          }

          // Adjust vertical position: If not enough space below, try above
          if (
            top + tooltipHeight > viewportHeight - spacing &&
            triggerRect.top - tooltipHeight - spacing > spacing
          ) {
            top = triggerRect.top - tooltipHeight - spacing;
          } else if (top + tooltipHeight > viewportHeight - spacing) {
            // Stick to bottom edge if needed
            top = viewportHeight - tooltipHeight - spacing;
          }

          // Ensure tooltip doesn't go off the top edge
          if (top < spacing) {
            top = spacing;
          }

          // Apply position - Using top/left is generally reliable
          this.tooltipElement.style.top = `${Math.round(top)}px`;
          this.tooltipElement.style.left = `${Math.round(left)}px`;
          // Reset transform if it was used previously
          this.tooltipElement.style.transform = "";
        }

        /**
         * Hides the tooltip immediately.
         * @param {boolean} [returnFocus=false] - If true, attempts to return focus to the trigger element.
         */
        hideTooltip(returnFocus = false) {
          clearTimeout(this.hideTooltipTimeout);
          const triggerToFocus = this.activeTooltipTrigger;

          if (this.activeTooltipTrigger && this.resizeObserver) {
            this.resizeObserver.unobserve(this.activeTooltipTrigger);
          }
          this.activeTooltipTrigger = null;
          this.tooltipElement.classList.remove("visible");
          this.tooltipElement.setAttribute("aria-hidden", "true");
          delete this.tooltipElement.dataset.type;

          if (
            returnFocus &&
            triggerToFocus &&
            typeof triggerToFocus.focus === "function"
          ) {
            if (
              document.body.contains(triggerToFocus) &&
              triggerToFocus.offsetParent !== null
            ) {
              requestAnimationFrame(() => {
                triggerToFocus.focus({ preventScroll: true });
              });
            }
          }
        }

        /**
         * Requests to hide the tooltip after a short delay (for hover intent).
         */
        requestHideTooltip() {
          clearTimeout(this.hideTooltipTimeout);
          this.hideTooltipTimeout = setTimeout(() => {
            // Check focus/hover on trigger OR tooltip
            const isFocusWithinTrigger = this.activeTooltipTrigger?.contains(
              document.activeElement
            );
            const isFocusWithinTooltip = this.tooltipElement.contains(
              document.activeElement
            );
            const isHoveringTooltip = this.tooltipElement.matches(":hover");
            const isHoveringTrigger =
              this.activeTooltipTrigger?.matches(":hover");

            if (
              !isFocusWithinTrigger &&
              !isFocusWithinTooltip &&
              !isHoveringTooltip &&
              !isHoveringTrigger
            ) {
              this.hideTooltip();
            }
          }, 150); // Delay for hover intent
        }

        /**
         * Sets the visual state (aria-pressed) of filter buttons.
         * @param {string} activeFilter - The data-filter value of the active button.
         */
        setActiveFilter(activeFilter) {
          this.filterButtons.forEach((button) => {
            const isPressed = button.dataset.filter === activeFilter;
            button.setAttribute("aria-pressed", String(isPressed));
          });
        }

        /**
         * Filters the app bubbles based on the selected model.
         * @param {string} filterValue - The model to filter by ('all' shows everything).
         */
        filterBubbles(filterValue) {
          let visibleCount = 0;
          this.appBubbles.forEach((bubbleData) => {
            const bubbleElement = bubbleData.element;
            // Ignore bubbles currently animating out
            if (bubbleElement.classList.contains("popping")) {
              // If a popping bubble *would* be visible, consider it visible for the count
              if (filterValue === "all" || bubbleData.model === filterValue) {
                visibleCount++;
              }
              return;
            }

            const isVisible =
              filterValue === "all" || bubbleData.model === filterValue;
            bubbleElement.classList.toggle("hidden", !isVisible);
            // Set aria-hidden based on visibility, but ensure it's true if hidden
            bubbleElement.setAttribute("aria-hidden", String(!isVisible));

            if (isVisible) {
              visibleCount++;
              // Ensure tabindex is 0 only if visible and not hidden
              bubbleElement.setAttribute("tabindex", "0");
            } else {
              // Remove from tab order if hidden
              bubbleElement.setAttribute("tabindex", "-1");
            }
          });

          this.emptyStateMessage.classList.toggle(
            "visible",
            visibleCount === 0
          );
        }
      }

      // --- Initialize ---
      function initializeShowcase() {
        new BubbleShowcase();
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeShowcase);
      } else {
        initializeShowcase();
      }
    </script>
  </body>
</html>
