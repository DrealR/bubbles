<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pok√©mon Battle Simulator Bubble</title>
    <style>
      :root {
        /* Color Palette (iOS Inspired) */
        --primary-color: #007aff; /* Blue */
        --secondary-color: #6c757d; /* Gray */
        --success-color: #34c759; /* Green */
        --warning-color: #ffcc00; /* Yellow */
        --danger-color: #ff3b30; /* Red */
        --info-color: #5ac8fa; /* Teal */
        --light-gray: #f2f2f7;
        --medium-gray: #e5e5ea;
        --dark-gray: #1c1c1e;
        --text-light: #ffffff;
        --text-dark: #1d1d1f;

        /* Fonts */
        --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        --font-mono: "SF Mono", "Consolas", "Monaco", "Courier New", monospace;

        /* Type Colors */
        --type-normal: #a8a77a;
        --type-normal-text: white;
        --type-fire: #f57d31;
        --type-fire-text: white;
        --type-water: #6390f0;
        --type-water-text: white;
        --type-electric: #f7d02c;
        --type-electric-text: var(--text-dark);
        --type-grass: #7ac74c;
        --type-grass-text: white;
        --type-ice: #96d9d6;
        --type-ice-text: var(--text-dark);
        --type-fighting: #c22e28;
        --type-fighting-text: white;
        --type-poison: #a33ea1;
        --type-poison-text: white;
        --type-ground: #e2bf65;
        --type-ground-text: var(--text-dark);
        --type-flying: #a98ff3;
        --type-flying-text: white;
        --type-psychic: #f95587;
        --type-psychic-text: white;
        --type-bug: #a6b91a;
        --type-bug-text: white;
        --type-rock: #b6a136;
        --type-rock-text: white;
        --type-ghost: #735797;
        --type-ghost-text: white;
        --type-dragon: #6f35fc;
        --type-dragon-text: white;
        --type-dark: #705746;
        --type-dark-text: white;
        --type-steel: #b7b7ce;
        --type-steel-text: var(--text-dark);
        --type-fairy: #d685ad;
        --type-fairy-text: white;
        --type-status: #8a8a8d;
        --type-status-text: white;

        /* Status Colors */
        --status-par-bg: var(--warning-color);
        --status-par-text: var(--text-dark);
        --status-brn-bg: var(--danger-color);
        --status-brn-text: white;
        --status-psn-bg: var(--type-poison);
        --status-psn-text: white;
        --status-slp-bg: var(--secondary-color);
        --status-slp-text: white;
        --status-frz-bg: var(--info-color);
        --status-frz-text: var(--text-dark);

        /* Bubble Specific */
        --bubble-pop-button-bg: rgba(
          242,
          242,
          247,
          0.8
        ); /* light-gray with alpha */
        --bubble-pop-button-bg-hover: rgba(242, 242, 247, 0.95);
        --bubble-pop-button-icon-color: var(--primary-color);
        --bubble-pop-button-icon-color-hover: #0056b3; /* Darker blue */
        --bubble-border-radius: 28px; /* Match battlefield */
        --bubble-pop-duration: 0.4s;
        --focus-ring: 0 0 0 3px rgba(0, 122, 255, 0.4); /* primary-color with alpha */
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html {
        font-size: 16px;
      }

      body {
        font-family: var(--font-sans);
        background-color: var(--light-gray);
        background-image: linear-gradient(
            45deg,
            rgba(0, 0, 0, 0.02) 25%,
            transparent 25%,
            transparent 75%,
            rgba(0, 0, 0, 0.02) 75%,
            rgba(0, 0, 0, 0.02)
          ),
          linear-gradient(
            45deg,
            rgba(0, 0, 0, 0.02) 25%,
            transparent 25%,
            transparent 75%,
            rgba(0, 0, 0, 0.02) 75%,
            rgba(0, 0, 0, 0.02)
          );
        background-size: 60px 60px;
        background-position: 0 0, 30px 30px;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: var(--text-dark);
        line-height: 1.6;
        min-height: 100vh;
        overflow-x: hidden;
        position: relative; /* For fixed elements */
      }

      /* Bubble Wrapper Styling */
      #bubble-wrapper {
        width: 100%;
        max-width: 900px; /* Slightly larger than battle container */
        min-height: 85vh; /* Ensure decent height */
        background: rgba(255, 255, 255, 0.7); /* Semi-transparent white base */
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        border-radius: var(--bubble-border-radius);
        box-shadow: 0 0 0 10px rgba(255, 255, 255, 0.3),
          0 15px 40px rgba(0, 0, 0, 0.12), 0 5px 15px rgba(0, 0, 0, 0.08); /* Glow + Existing Shadows */
        padding: 1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start; /* Align content to top */
        transition: transform var(--bubble-pop-duration)
            cubic-bezier(0.6, -0.28, 0.735, 0.045),
          /* EaseInBack */ opacity var(--bubble-pop-duration) ease-out;
        transform-origin: center center;
        overflow: hidden;
        position: relative; /* For pseudo-elements or inner absolute positioning */
        z-index: 1; /* Above body background */
      }
      @media (min-width: 768px) {
        #bubble-wrapper {
          padding: 1.5rem;
        }
      }

      /* Pop Out Animation */
      #bubble-wrapper.popping-out {
        transform: scale(1.5); /* Slightly larger pop */
        opacity: 0;
        pointer-events: none;
      }

      @keyframes pop-out-animation {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        100% {
          transform: scale(1.5);
          opacity: 0;
        }
      }

      /* Apply animation only if not reduced motion */
      @media (prefers-reduced-motion: no-preference) {
        #bubble-wrapper.popping-out {
          animation: pop-out-animation var(--bubble-pop-duration)
            cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards;
        }
      }

      /* Pop Bubble Button */
      #pop-bubble-button {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 1000; /* Above everything */
        width: 44px;
        height: 44px;
        background-color: var(--bubble-pop-button-bg);
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        transition: background-color 0.2s ease, transform 0.2s ease,
          box-shadow 0.2s ease;
        appearance: none;
        padding: 0;
      }

      #pop-bubble-button svg {
        width: 22px; /* Slightly smaller icon */
        height: 22px;
        color: var(--bubble-pop-button-icon-color);
        transition: color 0.2s ease;
      }

      #pop-bubble-button:hover {
        background-color: var(--bubble-pop-button-bg-hover);
        transform: scale(1.1);
        box-shadow: 0 5px 12px rgba(0, 0, 0, 0.18);
      }
      #pop-bubble-button:hover svg {
        color: var(--bubble-pop-button-icon-color-hover);
      }

      #pop-bubble-button:focus {
        outline: none;
      }
      #pop-bubble-button:focus-visible {
        box-shadow: var(--focus-ring), 0 3px 8px rgba(0, 0, 0, 0.12);
      }

      #pop-bubble-button:active {
        transform: scale(1);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      }
      @media (max-width: 640px) {
        #pop-bubble-button {
          top: 0.75rem;
          left: 0.75rem;
          width: 40px;
          height: 40px;
        }
        #pop-bubble-button svg {
          width: 20px;
          height: 20px;
        }
      }

      .battle-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 700px; /* Keep original max-width */
        gap: 1rem;
        /* Added margin top to space from bubble edge */
        margin-top: 1rem;
      }

      .battlefield {
        background: rgba(255, 255, 255, 0.95); /* More opaque */
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px); /* Safari */
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 28px; /* Even more rounded */
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.12),
          0 5px 15px rgba(0, 0, 0, 0.08);
        width: 100%;
        padding: 1.5rem 2rem; /* More padding */
        position: relative;
        overflow: hidden;
        transition: transform 0.3s ease-out; /* For screen shake */
      }
      .battlefield.shake {
        animation: screen-shake 0.3s linear;
      }
      @keyframes screen-shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-4px);
        }
        50% {
          transform: translateX(4px);
        }
        75% {
          transform: translateX(-4px);
        }
      }

      .side {
        display: flex;
        align-items: flex-end;
        gap: 1rem;
        margin-bottom: 3rem; /* Increased space */
        min-height: 120px; /* Taller */
        position: relative;
      }
      .side:last-child {
        margin-bottom: 0;
      }
      .left {
        justify-content: flex-start;
      }
      .right {
        justify-content: flex-end;
        text-align: right;
      }

      .avatar-container {
        width: 120px; /* Larger avatar */
        height: 120px;
        position: relative;
        flex-shrink: 0;
        transform: translateY(100%);
        opacity: 0;
        transition: transform 0.7s cubic-bezier(0.25, 1, 0.5, 1),
          opacity 0.6s ease-out;
      }
      .avatar-container.enter {
        transform: translateY(0);
        opacity: 1;
      }

      .avatar {
        width: 100%;
        height: 100%;
        background: var(--medium-gray);
        border-radius: 16px; /* More rounded */
        border: 4px solid transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        transition: transform 0.3s ease-out, filter 0.5s ease-out,
          border-color 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      .avatar img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        transition: transform 0.15s ease-in-out, opacity 0.5s ease-out;
        opacity: 0;
      }
      .avatar.placeholder {
        border: 4px dashed #a0a0a5;
        background: var(--light-gray);
      }

      .active .avatar {
        animation: active-bounce 1.3s infinite ease-in-out;
      }
      @keyframes active-bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-4px) scale(1.02);
        }
      }

      .stat-change-indicator {
        position: absolute;
        top: -12px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.8rem;
        font-weight: bold;
        opacity: 0;
        animation: stat-float 1.3s ease-out forwards;
        z-index: 5;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }
      .stat-up {
        color: var(--success-color);
      }
      .stat-down {
        color: var(--danger-color);
      }
      @keyframes stat-float {
        0% {
          opacity: 1;
          transform: translate(-50%, 10px) scale(0.8);
        }
        20% {
          transform: translate(-50%, -15px) scale(1.1);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -40px) scale(0.6);
        }
      }

      .hit .avatar img {
        animation: hit-shake 0.3s linear;
      }
      .opponent.hit .avatar img {
        animation: hit-shake-opponent 0.3s linear;
      }
      @keyframes hit-shake {
        /* Player */
        0%,
        100% {
          transform: translateX(0) scaleX(-1);
        }
        25%,
        75% {
          transform: translateX(-7px) scaleX(-1);
        }
        50% {
          transform: translateX(7px) scaleX(-1);
        }
      }
      @keyframes hit-shake-opponent {
        /* Opponent */
        0%,
        100% {
          transform: translateX(0);
        }
        25%,
        75% {
          transform: translateX(7px);
        }
        50% {
          transform: translateX(-7px);
        }
      }

      .fainted .avatar-container {
        animation: faint-fall 1.1s cubic-bezier(0.6, -0.28, 0.735, 0.045)
          forwards;
      }
      .fainted .avatar img {
        filter: grayscale(1) opacity(0.4);
        transition: filter 0.9s ease-out;
      }
      @keyframes faint-fall {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(70px) rotate(-20deg);
          opacity: 0;
        }
      }

      .info {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 1rem;
        flex-grow: 1;
        padding-bottom: 8px;
        position: relative;
      }
      .info .stat-change-indicator {
        top: -15px;
        left: 50%;
      }
      .right .info .stat-change-indicator {
        left: 50%;
      }

      .name-status {
        display: flex;
        align-items: center;
        gap: 0.7rem;
        margin-bottom: 0.3rem;
      }
      .right .name-status {
        justify-content: flex-end;
      }

      .name {
        font-weight: 700;
        font-size: 1.4rem;
      }
      .status-badge {
        font-size: 0.8rem;
        font-weight: bold;
        padding: 0.2rem 0.6rem;
        border-radius: 8px;
        text-transform: uppercase;
        color: var(--text-light);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
        transition: opacity 0.4s ease, transform 0.4s ease;
        opacity: 1;
        transform: scale(1);
      }
      .status-badge.hidden {
        opacity: 0;
        transform: scale(0.7);
        pointer-events: none;
      }
      .status-PAR {
        background-color: var(--status-par-bg);
        color: var(--status-par-text);
      }
      .status-BRN {
        background-color: var(--status-brn-bg);
        color: var(--status-brn-text);
      }
      .status-PSN {
        background-color: var(--status-psn-bg);
        color: var(--status-psn-text);
      }
      .status-SLP {
        background-color: var(--status-slp-bg);
        color: var(--status-slp-text);
      }
      .status-FRZ {
        background-color: var(--status-frz-bg);
        color: var(--status-frz-text);
      }

      .level {
        font-size: 0.9rem;
        color: var(--secondary-color);
      }
      .hp-bar {
        background: var(--medium-gray);
        border-radius: 999px;
        overflow: hidden;
        height: 16px; /* Thicker */
        width: 100%;
        max-width: 240px;
        border: 1px solid #bbb;
        position: relative;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.15);
      }
      .right .hp-bar {
        margin-left: auto;
      }
      .hp-fill {
        background: var(--success-color);
        height: 100%;
        transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1),
          background-color 0.5s ease-out;
        border-radius: 999px;
        position: relative;
      }
      .hp-bar::before {
        content: "HP";
        position: absolute;
        left: 8px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 10px;
        font-weight: bold;
        color: rgba(0, 0, 0, 0.7);
        line-height: 1;
        z-index: 1;
      }
      .hp-text {
        font-size: 0.9rem;
        color: var(--secondary-color);
        font-weight: 600;
        margin-top: 0.3rem;
      }
      .right .hp-text {
        text-align: right;
      }

      .console {
        background: var(--dark-gray);
        border-radius: 16px;
        color: var(--text-light);
        padding: 1.25rem;
        font-family: var(--font-mono);
        font-size: 0.95rem;
        min-height: 150px;
        max-height: 350px;
        overflow-y: auto;
        line-height: 1.6;
        width: 100%;
        box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.4);
        border: 1px solid #444;
        scrollbar-width: thin;
        scrollbar-color: var(--primary-color) #3a3a3c;
        scroll-behavior: smooth;
      }
      .console::-webkit-scrollbar {
        width: 8px;
      }
      .console::-webkit-scrollbar-track {
        background: #3a3a3c;
        border-radius: 4px;
      }
      .console::-webkit-scrollbar-thumb {
        background-color: var(--primary-color);
        border-radius: 4px;
        border: 2px solid #3a3a3c;
      }
      .console > div {
        padding-bottom: 0.4rem;
        margin-bottom: 0.4rem;
        border-bottom: 1px solid #4a4a4c;
        transition: background-color 0.5s ease;
      }
      .console > div:last-child {
        border-bottom: none;
      }
      .console > div.highlight {
        background-color: rgba(255, 255, 255, 0.1);
      }
      .console .effectiveness {
        font-style: italic;
        color: #a0a0a5;
      }
      .console .critical {
        font-weight: bold;
        color: var(--warning-color);
        animation: pulse-yellow 0.8s ease-in-out;
      }
      .console .status-change {
        color: var(--info-color);
        font-style: italic;
      }
      .console .stat-change {
        color: #b0b0b0;
        font-style: italic;
      }
      .console .turn-divider {
        text-align: center;
        font-weight: bold;
        color: var(--info-color);
        margin: 1rem 0;
        padding-bottom: 1rem;
        letter-spacing: 1.5px;
        border-color: var(--info-color) !important;
      }
      .console .game-over {
        text-align: center;
        font-weight: bold;
        font-size: 1.2rem;
        margin-top: 1.2rem;
        color: var(--success-color);
        animation: pulse-green 1s infinite;
      }
      .console .player-prompt {
        font-weight: bold;
        color: var(--primary-color);
      }
      .console .player-choice {
        color: #87cefa;
      }
      .console .opponent-choice {
        color: #ff7f7f;
      }
      .console .immune {
        font-style: italic;
        color: var(--secondary-color);
      }
      @keyframes pulse-yellow {
        0%,
        100% {
          text-shadow: 0 0 5px var(--warning-color);
        }
        50% {
          text-shadow: 0 0 15px var(--warning-color);
        }
      }
      @keyframes pulse-green {
        0%,
        100% {
          text-shadow: 0 0 5px var(--success-color);
        }
        50% {
          text-shadow: 0 0 15px var(--success-color);
        }
      }

      .attack-icon {
        position: absolute;
        font-size: 45px;
        pointer-events: none;
        z-index: 10;
        opacity: 1;
        transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275),
          opacity 0.8s ease-out;
        text-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        will-change: transform, opacity;
      }

      .player-controls {
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 0, 0, 0.07);
        border-radius: 20px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        padding: 1.25rem;
        width: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 1rem;
        transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        position: relative;
        will-change: opacity, transform;
      }
      .player-controls.hidden {
        opacity: 0;
        transform: translateY(40px);
        pointer-events: none;
      }

      .move-button {
        padding: 0.8rem 1.1rem;
        font-size: 1rem;
        font-weight: 600;
        border: none;
        border-radius: 14px;
        background-color: var(--medium-gray);
        color: var(--text-dark);
        cursor: pointer;
        text-align: center;
        transition: all 0.25s ease;
        position: relative;
        overflow: hidden;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.08);
        border: 1px solid rgba(0, 0, 0, 0.1);
      }
      .move-button:hover:not(:disabled) {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.12);
        transform: translateY(-3px);
        filter: brightness(1.05);
      }
      .move-button:active:not(:disabled) {
        transform: scale(0.95) translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        filter: brightness(0.95);
      }
      .move-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        background-color: var(--medium-gray) !important;
        box-shadow: none;
        color: var(--secondary-color) !important;
        filter: grayscale(50%);
      }
      .move-button:disabled .move-pp {
        color: var(--secondary-color) !important;
      }
      .move-pp {
        font-size: 0.75rem;
        color: rgba(0, 0, 0, 0.55);
        display: block;
        margin-top: 4px;
        font-weight: 500;
      }

      /* Type-specific button styling */
      .move-button[data-type="Normal"] {
        background-color: var(--type-normal);
        color: var(--type-normal-text);
        --button-text-color: var(--type-normal-text);
      }
      .move-button[data-type="Fire"] {
        background-color: var(--type-fire);
        color: var(--type-fire-text);
        --button-text-color: var(--type-fire-text);
      }
      .move-button[data-type="Water"] {
        background-color: var(--type-water);
        color: var(--type-water-text);
        --button-text-color: var(--type-water-text);
      }
      .move-button[data-type="Electric"] {
        background-color: var(--type-electric);
        color: var(--type-electric-text);
        --button-text-color: var(--type-electric-text);
      }
      .move-button[data-type="Grass"] {
        background-color: var(--type-grass);
        color: var(--type-grass-text);
        --button-text-color: var(--type-grass-text);
      }
      .move-button[data-type="Ice"] {
        background-color: var(--type-ice);
        color: var(--type-ice-text);
        --button-text-color: var(--type-ice-text);
      }
      .move-button[data-type="Fighting"] {
        background-color: var(--type-fighting);
        color: var(--type-fighting-text);
        --button-text-color: var(--type-fighting-text);
      }
      .move-button[data-type="Poison"] {
        background-color: var(--type-poison);
        color: var(--type-poison-text);
        --button-text-color: var(--type-poison-text);
      }
      .move-button[data-type="Ground"] {
        background-color: var(--type-ground);
        color: var(--type-ground-text);
        --button-text-color: var(--type-ground-text);
      }
      .move-button[data-type="Flying"] {
        background-color: var(--type-flying);
        color: var(--type-flying-text);
        --button-text-color: var(--type-flying-text);
      }
      .move-button[data-type="Psychic"] {
        background-color: var(--type-psychic);
        color: var(--type-psychic-text);
        --button-text-color: var(--type-psychic-text);
      }
      .move-button[data-type="Bug"] {
        background-color: var(--type-bug);
        color: var(--type-bug-text);
        --button-text-color: var(--type-bug-text);
      }
      .move-button[data-type="Rock"] {
        background-color: var(--type-rock);
        color: var(--type-rock-text);
        --button-text-color: var(--type-rock-text);
      }
      .move-button[data-type="Ghost"] {
        background-color: var(--type-ghost);
        color: var(--type-ghost-text);
        --button-text-color: var(--type-ghost-text);
      }
      .move-button[data-type="Dragon"] {
        background-color: var(--type-dragon);
        color: var(--type-dragon-text);
        --button-text-color: var(--type-dragon-text);
      }
      .move-button[data-type="Dark"] {
        background-color: var(--type-dark);
        color: var(--type-dark-text);
        --button-text-color: var(--type-dark-text);
      }
      .move-button[data-type="Steel"] {
        background-color: var(--type-steel);
        color: var(--type-steel-text);
        --button-text-color: var(--type-steel-text);
      }
      .move-button[data-type="Fairy"] {
        background-color: var(--type-fairy);
        color: var(--type-fairy-text);
        --button-text-color: var(--type-fairy-text);
      }
      .move-button[data-category="Status"] {
        background-color: var(--type-status);
        color: var(--type-status-text);
        --button-text-color: var(--type-status-text);
      }
      .move-button[data-type] .move-pp,
      .move-button[data-category="Status"] .move-pp {
        color: color-mix(
          in srgb,
          var(--button-text-color, black) 65%,
          transparent
        );
      }

      .restart-button {
        margin-top: 1.5rem;
        padding: 0.9rem 1.8rem;
        font-size: 1.1rem;
        font-weight: 600;
        border: none;
        border-radius: 14px;
        background-color: var(--primary-color);
        color: white;
        cursor: pointer;
        transition: all 0.25s ease;
        box-shadow: 0 5px 12px rgba(0, 122, 255, 0.35);
        display: inline-block;
      }
      .restart-button:hover {
        background-color: #005fcc;
        box-shadow: 0 7px 15px rgba(0, 122, 255, 0.45);
        transform: translateY(-2px);
      }
      .restart-button:active {
        background-color: #004080;
        transform: translateY(0);
        box-shadow: 0 3px 7px rgba(0, 122, 255, 0.25);
      }
      .restart-button.hidden {
        display: none;
      }

      /* Prompt Info Footer */
      .prompt-info {
        text-align: center;
        margin-top: 1.5rem; /* Space above */
        padding-top: 1rem;
        border-top: 1px solid var(--medium-gray);
        width: 100%;
        max-width: 700px;
        font-size: 0.8rem;
        color: var(--secondary-color);
        line-height: 1.5;
        position: relative; /* Ensure it's within the flow */
        z-index: 1; /* Above background overlay */
      }
      .prompt-info code {
        background-color: rgba(0, 122, 255, 0.1); /* primary-color with alpha */
        color: var(--primary-color);
        padding: 0.2em 0.5em;
        border-radius: 4px;
        font-family: var(--font-mono);
        font-size: 0.9em;
      }

      /* Media Query for smaller screens */
      @media (max-width: 640px) {
        body {
          padding: 0.5rem;
        }
        #bubble-wrapper {
          padding: 0.75rem;
          min-height: 90vh;
        }
        .battle-container {
          gap: 0.75rem;
          margin-top: 0.5rem;
        }
        .battlefield {
          padding: 1rem 1.25rem;
          border-radius: 20px;
        }
        .side {
          margin-bottom: 2rem;
          gap: 0.75rem;
          min-height: 100px;
        }
        .avatar-container {
          width: 100px;
          height: 100px;
        }
        .avatar {
          border-radius: 12px;
          border-width: 3px;
        }
        .info {
          gap: 0.3rem;
          padding-bottom: 5px;
        }
        .name {
          font-size: 1.2rem;
        }
        .level {
          font-size: 0.8rem;
        }
        .hp-bar {
          height: 14px;
          max-width: 190px;
          border-width: 1px;
        }
        .hp-bar::before {
          font-size: 9px;
          left: 6px;
        }
        .hp-text {
          font-size: 0.8rem;
        }
        .console {
          min-height: 120px;
          max-height: 250px;
          font-size: 0.85rem;
          padding: 1rem;
          border-radius: 12px;
        }
        .player-controls {
          padding: 1rem;
          gap: 0.75rem;
          grid-template-columns: repeat(2, 1fr);
          border-radius: 16px;
        }
        .move-button {
          padding: 0.7rem 0.9rem;
          font-size: 0.9rem;
          border-radius: 12px;
        }
        .move-pp {
          font-size: 0.7rem;
        }
        .attack-icon {
          font-size: 35px;
        }
        .restart-button {
          padding: 0.8rem 1.5rem;
          font-size: 1rem;
          margin-top: 1rem;
        }
        .prompt-info {
          font-size: 0.75rem;
          margin-top: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- Pop Bubble Button -->
    <button id="pop-bubble-button" aria-label="Pop bubble and return home">
      <svg
        aria-hidden="true"
        focusable="false"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M6.758 17.243L12.001 12m5.243-5.243L12 12m0 0L6.758 6.757M12.001 12l5.243 5.243"
          stroke="currentColor"
          stroke-width="2.5"
          stroke-linecap="round"
          stroke-linejoin="round"
        />
      </svg>
    </button>

    <!-- Main Content Wrapper -->
    <div id="bubble-wrapper">
      <div class="battle-container">
        <div class="battlefield" id="battlefield">
          <!-- Opponent Side -->
          <div class="side right opponent" id="opponent-side">
            <div class="info">
              <div class="name-status">
                <span class="status-badge hidden" id="pokemon1-status"></span>
                <div class="name" id="pokemon1-name">Opponent</div>
              </div>
              <div class="level" id="pokemon1-level">Lv. ?</div>
              <div class="hp-bar">
                <div class="hp-fill" id="pokemon1-hp"></div>
              </div>
              <div class="hp-text" id="pokemon1-hp-text">? / ? HP</div>
            </div>
            <div class="avatar-container" id="pokemon1-avatar-container">
              <div class="avatar placeholder" id="pokemon1-avatar"></div>
            </div>
          </div>

          <!-- Player Side -->
          <div class="side left player" id="player-side">
            <div class="avatar-container" id="pokemon2-avatar-container">
              <div class="avatar placeholder" id="pokemon2-avatar"></div>
            </div>
            <div class="info">
              <div class="name-status">
                <div class="name" id="pokemon2-name">Player</div>
                <span class="status-badge hidden" id="pokemon2-status"></span>
              </div>
              <div class="level" id="pokemon2-level">Lv. ?</div>
              <div class="hp-bar">
                <div class="hp-fill" id="pokemon2-hp"></div>
              </div>
              <div class="hp-text" id="pokemon2-hp-text">? / ? HP</div>
            </div>
          </div>
        </div>

        <div class="console" id="console">
          Initializing Battle Environment...
        </div>

        <div class="player-controls hidden" id="player-controls">
          <!-- Move buttons will be generated here -->
        </div>

        <button id="restart-button" class="restart-button hidden">
          Battle Again!
        </button>
      </div>
      <!-- End .battle-container -->

      <footer class="prompt-info">
        <p>
          This Bubble was generated from the prompt:
          <code
            >Generate JavaScript code for a turn-based Pok√©mon battle simulator
            engine...[details omitted]...Style it as if it's an apple expert
            designer...[details omitted]...</code
          >
          with refinement:
          <code
            >add a way to go back to the index.html file...[details
            omitted]...like a bubble thing where you burst it...</code
          >
        </p>
      </footer>
    </div>
    <!-- End #bubble-wrapper -->

    <script>
      // ********* MODULE: GLOBAL STATE & CONSTANTS **************
      const BATTLE_STATE = {
        playerPokemon: null,
        opponentPokemon: null,
        isPlayerTurn: false,
        waitingForPlayer: false,
        gameOver: false,
        playerMoveResolver: null,
        turnCounter: 0,
        battleLog: [],
        isProcessing: false,
      };

      const STATUS_EFFECTS = {
        PAR: {
          name: "PAR",
          badgeText: "PAR",
          cssClass: "status-PAR",
          turnStartEffect: true,
        },
        BRN: {
          name: "BRN",
          badgeText: "BRN",
          cssClass: "status-BRN",
          turnEndEffect: true,
        },
        PSN: {
          name: "PSN",
          badgeText: "PSN",
          cssClass: "status-PSN",
          turnEndEffect: true,
        },
        SLP: {
          name: "SLP",
          badgeText: "SLP",
          cssClass: "status-SLP",
          turnStartEffect: true,
        },
        FRZ: {
          name: "FRZ",
          badgeText: "FRZ",
          cssClass: "status-FRZ",
          turnStartEffect: true,
        },
      };

      const ANIMATION_DELAY = {
        SHORT: 400,
        MEDIUM: 700,
        LONG: 900,
        HP_BAR: 600,
        ATTACK_ICON: 800,
        FAINT: 1100,
        TURN_TRANSITION: 600,
        STATUS_EFFECT: 800,
        STAT_CHANGE: 1300,
        ENTRY: 700,
      };

      const ACC_EVA_MULTIPLIERS = {
        "-6": 3 / 9,
        "-5": 3 / 8,
        "-4": 3 / 7,
        "-3": 3 / 6,
        "-2": 3 / 5,
        "-1": 3 / 4,
        0: 1,
        1: 4 / 3,
        2: 5 / 3,
        3: 6 / 3,
        4: 7 / 3,
        5: 8 / 3,
        6: 9 / 3,
      };
      const STAT_STAGE_MULTIPLIERS = {
        "-6": 2 / 8,
        "-5": 2 / 7,
        "-4": 2 / 6,
        "-3": 2 / 5,
        "-2": 2 / 4,
        "-1": 2 / 3,
        0: 1,
        1: 3 / 2,
        2: 4 / 2,
        3: 5 / 2,
        4: 6 / 2,
        5: 7 / 2,
        6: 8 / 2,
      };

      const TYPE_CHART = {
        /* ... Type chart data remains the same ... */
        Normal: { Rock: 0.5, Ghost: 0, Steel: 0.5 },
        Fire: {
          Fire: 0.5,
          Water: 0.5,
          Grass: 2,
          Ice: 2,
          Bug: 2,
          Rock: 0.5,
          Dragon: 0.5,
          Steel: 2,
        },
        Water: {
          Fire: 2,
          Water: 0.5,
          Grass: 0.5,
          Ground: 2,
          Rock: 2,
          Dragon: 0.5,
        },
        Electric: {
          Water: 2,
          Electric: 0.5,
          Grass: 0.5,
          Ground: 0,
          Flying: 2,
          Dragon: 0.5,
        },
        Grass: {
          Fire: 0.5,
          Water: 2,
          Grass: 0.5,
          Poison: 0.5,
          Ground: 2,
          Flying: 0.5,
          Bug: 0.5,
          Rock: 2,
          Dragon: 0.5,
          Steel: 0.5,
        },
        Ice: {
          Fire: 0.5,
          Water: 0.5,
          Grass: 2,
          Ice: 0.5,
          Ground: 2,
          Flying: 2,
          Dragon: 2,
          Steel: 0.5,
        },
        Fighting: {
          Normal: 2,
          Flying: 0.5,
          Poison: 0.5,
          Rock: 2,
          Bug: 0.5,
          Ghost: 0,
          Psychic: 0.5,
          Ice: 2,
          Dark: 2,
          Steel: 2,
          Fairy: 0.5,
        },
        Poison: {
          Grass: 2,
          Poison: 0.5,
          Ground: 0.5,
          Rock: 0.5,
          Ghost: 0.5,
          Steel: 0,
          Fairy: 2,
        },
        Ground: {
          Fire: 2,
          Electric: 2,
          Grass: 0.5,
          Poison: 2,
          Flying: 0,
          Bug: 0.5,
          Rock: 2,
          Steel: 2,
        },
        Flying: {
          Electric: 0.5,
          Grass: 2,
          Fighting: 2,
          Bug: 2,
          Rock: 0.5,
          Steel: 0.5,
        },
        Psychic: { Fighting: 2, Poison: 2, Psychic: 0.5, Dark: 0, Steel: 0.5 },
        Bug: {
          Fire: 0.5,
          Grass: 2,
          Fighting: 0.5,
          Poison: 0.5,
          Flying: 0.5,
          Psychic: 2,
          Ghost: 0.5,
          Dark: 2,
          Steel: 0.5,
          Fairy: 0.5,
        },
        Rock: {
          Fire: 2,
          Ice: 2,
          Fighting: 0.5,
          Ground: 0.5,
          Flying: 2,
          Bug: 2,
          Steel: 0.5,
        },
        Ghost: { Normal: 0, Psychic: 2, Ghost: 2, Dark: 0.5 },
        Dragon: { Dragon: 2, Steel: 0.5, Fairy: 0 },
        Dark: { Fighting: 0.5, Psychic: 2, Ghost: 2, Dark: 0.5, Fairy: 0.5 },
        Steel: {
          Normal: 1,
          Fire: 0.5,
          Water: 0.5,
          Electric: 0.5,
          Grass: 1,
          Ice: 2,
          Fighting: 1,
          Poison: 1,
          Ground: 1,
          Flying: 1,
          Psychic: 1,
          Bug: 1,
          Rock: 2,
          Ghost: 1,
          Dragon: 1,
          Dark: 1,
          Steel: 0.5,
          Fairy: 2,
        },
        Fairy: {
          Fire: 0.5,
          Fighting: 2,
          Poison: 0.5,
          Dragon: 2,
          Dark: 2,
          Steel: 0.5,
        },
      };

      const ATTACK_ICONS = {
        /* ... Attack icons data remains the same ... */ Fire: "üî•",
        Water: "üíß",
        Grass: "üåø",
        Electric: "‚ö°",
        Normal: "‚≠ê",
        Fighting: "‚úä",
        Psychic: "üåÄ",
        Ghost: "üëª",
        Rock: "üóø",
        Ground: "‚õ∞Ô∏è",
        Flying: "üïäÔ∏è",
        Bug: "üêû",
        Poison: "‚ò†Ô∏è",
        Ice: "‚ùÑÔ∏è",
        Dragon: "üêâ",
        Dark: "üåë",
        Steel: "üî©",
        Fairy: "‚ú®",
        Status: "üí´",
      };

      const CRIT_CHANCE = 1 / 24;
      const PARALYSIS_CHANCE = 0.25;
      const THAW_CHANCE = 0.2;

      // ********* MODULE: POKEMON DATA & CLASS **************
      class Pokemon {
        /* ... Pokemon class remains the same ... */
        constructor(name, level, types, stats, moves, sprite) {
          this.name = name;
          this.level = level;
          this.types = Array.isArray(types) ? types : [types];
          this.baseStats = stats;
          this.moves = moves.map((m) => ({ ...m, currentPP: m.pp }));
          this.sprite = sprite;
          this.id = Math.random().toString(36).substring(7);
          this.reset();
        }
        reset() {
          this.currentStats = { ...this.baseStats };
          this.level = this.level;
          this.maxHp = this.calculateStatValue(
            this.baseStats.hp,
            this.level,
            true
          );
          this.hp = this.maxHp;
          this.status = null;
          this.statusCounter = 0;
          this.isFainted = false;
          this.statStages = {
            atk: 0,
            def: 0,
            spa: 0,
            spd: 0,
            spe: 0,
            accuracy: 0,
            evasion: 0,
          };
          this.moves.forEach((m) => (m.currentPP = m.pp));
        }
        calculateStatValue(base, level, isHp = false) {
          if (isHp) {
            if (base === 1) return 1;
            return Math.floor((base * 2 * level) / 100 + level + 10);
          } else {
            return Math.floor((base * 2 * level) / 100 + 5);
          }
        }
        getModifiedStat(
          statName,
          ignorePositiveStages = false,
          ignoreNegativeStages = false
        ) {
          const baseStatValue = this.calculateStatValue(
            this.currentStats[statName],
            this.level
          );
          if (!baseStatValue) return 1;
          let stage = this.statStages[statName];
          if (
            (statName === "def" || statName === "spd") &&
            ignorePositiveStages &&
            stage > 0
          )
            stage = 0;
          if (
            (statName === "atk" || statName === "spa") &&
            ignoreNegativeStages &&
            stage < 0
          )
            stage = 0;
          const multiplier = STAT_STAGE_MULTIPLIERS[stage] || 1.0;
          let finalStat = baseStatValue * multiplier;
          if (
            statName === "atk" &&
            this.status === "BRN" &&
            !ignoreNegativeStages
          )
            finalStat *= 0.5;
          if (statName === "spe" && this.status === "PAR") finalStat *= 0.5;
          return Math.max(1, Math.floor(finalStat));
        }
        applyStatus(status, sourcePokemon = null) {
          if (this.status || this.isFainted) {
            if (this.status)
              log(
                `${this.name} is already afflicted with ${
                  STATUS_EFFECTS[this.status].badgeText
                }!`,
                "immune"
              );
            return false;
          }
          if (status === "BRN" && this.types.includes("Fire")) return false;
          if (
            status === "PSN" &&
            (this.types.includes("Poison") || this.types.includes("Steel"))
          )
            return false;
          if (status === "PAR" && this.types.includes("Electric")) return false;
          if (status === "FRZ" && this.types.includes("Ice")) return false;
          this.status = status;
          this.statusCounter = 0;
          let statusMsg = `${this.name} was afflicted with ${STATUS_EFFECTS[status].badgeText}!`;
          if (status === "SLP") {
            this.statusCounter = Math.floor(Math.random() * 3) + 1;
            statusMsg = `${this.name} fell asleep!`;
          }
          log(statusMsg, "status-change");
          return true;
        }
        clearStatus() {
          if (this.status) {
            log(
              `${this.name} is no longer ${
                STATUS_EFFECTS[this.status].badgeText
              }.`,
              "status-change"
            );
            this.status = null;
            this.statusCounter = 0;
            return true;
          }
          return false;
        }
        changeStatStage(statName, change, showIndicator = true) {
          if (!this.statStages.hasOwnProperty(statName) || this.isFainted)
            return false;
          const currentStage = this.statStages[statName];
          const newStage = Math.max(-6, Math.min(6, currentStage + change));
          const actualChange = newStage - currentStage;
          if (actualChange === 0) {
            log(
              `${this.name}'s ${statName.toUpperCase()} won't go any ${
                change > 0 ? "higher" : "lower"
              }!`,
              "stat-change"
            );
            return false;
          } else {
            this.statStages[statName] = newStage;
            let changeText =
              Math.abs(actualChange) >= 2
                ? `sharply ${change > 0 ? "rose" : "fell"}`
                : `${change > 0 ? "rose" : "fell"}`;
            log(
              `${this.name}'s ${statName.toUpperCase()} ${changeText}!`,
              "stat-change"
            );
            if (showIndicator) {
              const targetSide =
                this === BATTLE_STATE.playerPokemon
                  ? "player-side"
                  : "opponent-side";
              showStatChangeIndicator(targetSide, actualChange > 0);
            }
            return true;
          }
        }
        heal(percent) {
          if (this.isFainted || this.hp >= this.maxHp) return false;
          const healAmount = Math.floor(this.maxHp * percent);
          const healedHp = Math.min(this.maxHp, this.hp + healAmount);
          const actualHeal = healedHp - this.hp;
          if (actualHeal <= 0) return false;
          this.hp = healedHp;
          log(`${this.name} recovered ${actualHeal} HP!`, "status-change");
          return true;
        }
      }

      const MOVES = {
        /* ... Moves data remains the same ... */
        Tackle: {
          name: "Tackle",
          type: "Normal",
          power: 40,
          accuracy: 1,
          pp: 35,
          category: "Physical",
          priority: 0,
        },
        Scratch: {
          name: "Scratch",
          type: "Normal",
          power: 40,
          accuracy: 1,
          pp: 35,
          category: "Physical",
          priority: 0,
        },
        QuickAttack: {
          name: "Quick Attack",
          type: "Normal",
          power: 40,
          accuracy: 1,
          pp: 30,
          category: "Physical",
          priority: 1,
        },
        PoisonSting: {
          name: "Poison Sting",
          type: "Poison",
          power: 15,
          accuracy: 1,
          pp: 35,
          category: "Physical",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "PSN",
            chance: 0.3,
          },
        },
        BodySlam: {
          name: "Body Slam",
          type: "Normal",
          power: 85,
          accuracy: 1,
          pp: 15,
          category: "Physical",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "PAR",
            chance: 0.3,
          },
        },
        VineWhip: {
          name: "Vine Whip",
          type: "Grass",
          power: 45,
          accuracy: 1,
          pp: 25,
          category: "Special",
          priority: 0,
        },
        Ember: {
          name: "Ember",
          type: "Fire",
          power: 40,
          accuracy: 1,
          pp: 25,
          category: "Special",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "BRN",
            chance: 0.1,
          },
        },
        WaterGun: {
          name: "Water Gun",
          type: "Water",
          power: 40,
          accuracy: 1,
          pp: 25,
          category: "Special",
          priority: 0,
        },
        ThunderShock: {
          name: "Thunder Shock",
          type: "Electric",
          power: 40,
          accuracy: 1,
          pp: 30,
          category: "Special",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "PAR",
            chance: 0.1,
          },
        },
        IceBeam: {
          name: "Ice Beam",
          type: "Ice",
          power: 90,
          accuracy: 1,
          pp: 10,
          category: "Special",
          priority: 0,
          effect: {
            type: "apply_status_chance",
            target: "opponent",
            status: "FRZ",
            chance: 0.1,
          },
        },
        Psychic: {
          name: "Psychic",
          type: "Psychic",
          power: 90,
          accuracy: 1,
          pp: 10,
          category: "Special",
          priority: 0,
          effect: {
            type: "lower_stat_chance",
            target: "opponent",
            stat: "spd",
            stages: -1,
            chance: 0.1,
          },
        },
        Growl: {
          name: "Growl",
          type: "Normal",
          power: 0,
          accuracy: 1,
          pp: 40,
          category: "Status",
          priority: 0,
          effect: {
            type: "lower_stat",
            target: "opponent",
            stat: "atk",
            stages: -1,
          },
        },
        TailWhip: {
          name: "Tail Whip",
          type: "Normal",
          power: 0,
          accuracy: 1,
          pp: 30,
          category: "Status",
          priority: 0,
          effect: {
            type: "lower_stat",
            target: "opponent",
            stat: "def",
            stages: -1,
          },
        },
        ThunderWave: {
          name: "Thunder Wave",
          type: "Electric",
          power: 0,
          accuracy: 0.9,
          pp: 20,
          category: "Status",
          priority: 0,
          effect: { type: "apply_status", target: "opponent", status: "PAR" },
        },
        WillOWisp: {
          name: "Will-O-Wisp",
          type: "Fire",
          power: 0,
          accuracy: 0.85,
          pp: 15,
          category: "Status",
          priority: 0,
          effect: { type: "apply_status", target: "opponent", status: "BRN" },
        },
        SleepPowder: {
          name: "Sleep Powder",
          type: "Grass",
          power: 0,
          accuracy: 0.75,
          pp: 15,
          category: "Status",
          priority: 0,
          effect: { type: "apply_status", target: "opponent", status: "SLP" },
        },
        SwordsDance: {
          name: "Swords Dance",
          type: "Normal",
          power: 0,
          accuracy: null,
          pp: 20,
          category: "Status",
          priority: 0,
          effect: {
            type: "raise_stat",
            target: "self",
            stat: "atk",
            stages: 2,
          },
        },
        Recover: {
          name: "Recover",
          type: "Normal",
          power: 0,
          accuracy: null,
          pp: 10,
          category: "Status",
          priority: 0,
          effect: { type: "heal_percent", target: "self", amount: 0.5 },
        },
        Struggle: {
          name: "Struggle",
          type: "Normal",
          power: 50,
          accuracy: null,
          pp: Infinity,
          category: "Physical",
          priority: 0,
          effect: { type: "recoil_user_maxhp_percent", amount: 0.25 },
          ignoresTypeImmunity: true,
          isStruggle: true,
        },
      };

      const POKEMON_DATA = {
        /* ... Pokemon data remains the same ... */
        Bulbasaur: {
          name: "Bulbasaur",
          level: 5,
          types: ["Grass", "Poison"],
          stats: { hp: 45, atk: 49, def: 49, spa: 65, spd: 65, spe: 45 },
          moves: [MOVES.Tackle, MOVES.VineWhip, MOVES.Growl, MOVES.SleepPowder],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png",
        },
        Charmander: {
          name: "Charmander",
          level: 5,
          types: ["Fire"],
          stats: { hp: 39, atk: 52, def: 43, spa: 60, spd: 50, spe: 65 },
          moves: [MOVES.Scratch, MOVES.Ember, MOVES.Growl, MOVES.WillOWisp],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/4.png",
        },
        Squirtle: {
          name: "Squirtle",
          level: 5,
          types: ["Water"],
          stats: { hp: 44, atk: 48, def: 65, spa: 50, spd: 64, spe: 43 },
          moves: [MOVES.Tackle, MOVES.WaterGun, MOVES.TailWhip, MOVES.Recover],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/7.png",
        },
        Pikachu: {
          name: "Pikachu",
          level: 6,
          types: ["Electric"],
          stats: { hp: 35, atk: 55, def: 40, spa: 50, spd: 50, spe: 90 },
          moves: [
            MOVES.ThunderShock,
            MOVES.QuickAttack,
            MOVES.TailWhip,
            MOVES.ThunderWave,
          ],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png",
        },
        Staryu: {
          name: "Staryu",
          level: 5,
          types: ["Water"],
          stats: { hp: 30, atk: 45, def: 55, spa: 70, spd: 55, spe: 85 },
          moves: [MOVES.WaterGun, MOVES.Recover, MOVES.IceBeam, MOVES.Psychic],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/120.png",
        },
        Meowth: {
          name: "Meowth",
          level: 5,
          types: ["Normal"],
          stats: { hp: 40, atk: 45, def: 35, spa: 40, spd: 40, spe: 90 },
          moves: [
            MOVES.Scratch,
            MOVES.Growl,
            MOVES.QuickAttack,
            MOVES.BodySlam,
          ],
          sprite:
            "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/52.png",
        },
      };

      function clonePokemon(baseData) {
        return new Pokemon(
          baseData.name,
          baseData.level,
          [...baseData.types],
          { ...baseData.stats },
          baseData.moves.map((m) => ({ ...m })),
          baseData.sprite
        );
      }

      // ********* MODULE: BATTLE LOGIC **************
      function calculateTypeEffectiveness(
        moveType,
        targetTypes,
        ignoreImmunity = false
      ) {
        /* ... unchanged ... */
        let multiplier = 1;
        if (!moveType || moveType === "Status") return 1;
        targetTypes.forEach((targetType) => {
          const effectivenessMap = TYPE_CHART[moveType];
          if (effectivenessMap && effectivenessMap[targetType] !== undefined) {
            multiplier *= effectivenessMap[targetType];
          }
          if (!ignoreImmunity) {
            if (multiplier === 0) return; // Already immune
            if (moveType === "Ground" && targetType === "Flying")
              multiplier = 0;
            if (moveType === "Electric" && targetType === "Ground")
              multiplier = 0;
            if (moveType === "Psychic" && targetType === "Dark") multiplier = 0;
            if (moveType === "Poison" && targetType === "Steel") multiplier = 0;
            if (moveType === "Dragon" && targetType === "Fairy") multiplier = 0;
            if (moveType === "Normal" && targetType === "Ghost") multiplier = 0;
            if (moveType === "Fighting" && targetType === "Ghost")
              multiplier = 0;
          }
        });
        return multiplier;
      }
      function calculateAccuracy(attacker, move, defender) {
        /* ... unchanged ... */
        if (move.accuracy === null || move.accuracy === undefined) return true;
        if (
          move.accuracy >= 1 &&
          attacker.statStages.accuracy <= 0 &&
          defender.statStages.evasion >= 0
        )
          return true;
        const baseAccuracy = move.accuracy;
        const attackerAccStage = Math.max(
          -6,
          Math.min(6, attacker.statStages.accuracy)
        );
        const defenderEvaStage = Math.max(
          -6,
          Math.min(6, defender.statStages.evasion)
        );
        const accMultiplier = ACC_EVA_MULTIPLIERS[attackerAccStage];
        const evaMultiplier = ACC_EVA_MULTIPLIERS[-defenderEvaStage];
        const finalAccuracy = baseAccuracy * accMultiplier * evaMultiplier;
        return Math.random() < finalAccuracy;
      }
      function calculateDamage(attacker, move, defender) {
        /* ... unchanged ... */
        if (move.power <= 0 || move.category === "Status")
          return { damage: 0, effectiveness: 1, crit: false, recoilDamage: 0 };
        const isCritical = Math.random() < CRIT_CHANCE;
        const critMultiplier = isCritical ? 1.5 : 1;
        const ignoreNegativeAtk = isCritical;
        const ignorePositiveDef = isCritical;
        let attackStatValue, defenseStatValue;
        if (move.category === "Physical") {
          attackStatValue = attacker.getModifiedStat(
            "atk",
            false,
            ignoreNegativeAtk
          );
          defenseStatValue = defender.getModifiedStat(
            "def",
            ignorePositiveDef,
            false
          );
        } else if (move.category === "Special") {
          attackStatValue = attacker.getModifiedStat(
            "spa",
            false,
            ignoreNegativeAtk
          );
          defenseStatValue = defender.getModifiedStat(
            "spd",
            ignorePositiveDef,
            false
          );
        } else {
          return { damage: 0, effectiveness: 1, crit: false, recoilDamage: 0 };
        }
        let damage =
          (((2 * attacker.level) / 5 + 2) *
            move.power *
            (attackStatValue / defenseStatValue)) /
            50 +
          2;
        const isSTAB = attacker.types.includes(move.type);
        const stabMultiplier = isSTAB ? 1.5 : 1;
        const typeEffectiveness = calculateTypeEffectiveness(
          move.type,
          defender.types,
          move.ignoresTypeImmunity
        );
        const randomVariance = Math.random() * (1.0 - 0.85) + 0.85;
        damage *= stabMultiplier;
        damage *= typeEffectiveness;
        damage *= critMultiplier;
        damage *= randomVariance;
        damage = typeEffectiveness === 0 || damage < 1 ? 0 : Math.floor(damage);
        if (typeEffectiveness > 0 && damage === 0) damage = 1;
        let recoilDamage = 0;
        if (move.effect?.type === "recoil_damage_percent" && damage > 0)
          recoilDamage = Math.max(
            1,
            Math.floor(damage * (move.effect.amount || 0))
          );
        else if (move.effect?.type === "recoil_user_maxhp_percent")
          recoilDamage = Math.max(
            1,
            Math.floor(attacker.maxHp * (move.effect.amount || 0))
          );
        return {
          damage: Math.floor(damage),
          effectiveness: typeEffectiveness,
          crit: isCritical,
          recoilDamage: recoilDamage,
        };
      }

      // ********* MODULE: UI & ANIMATION **************
      function log(msg, type = "") {
        /* ... unchanged ... */
        const consolePanel = document.getElementById("console");
        if (!consolePanel) return;
        const logEntry = document.createElement("div");
        logEntry.innerHTML = msg;
        if (type) logEntry.classList.add(type);
        consolePanel.appendChild(logEntry);
        BATTLE_STATE.battleLog.push({ msg, type });
        logEntry.classList.add("highlight");
        setTimeout(() => logEntry.classList.remove("highlight"), 800);
        consolePanel.scrollTop = consolePanel.scrollHeight;
        console.log(msg.replace(/<[^>]*>/g, ""));
      }
      function updateHPDisplay(pokemon, elPrefix) {
        /* ... unchanged ... */
        const fill = document.getElementById(`${elPrefix}-hp`);
        const hpText = document.getElementById(`${elPrefix}-hp-text`);
        const sideContainer = document.getElementById(
          elPrefix === "pokemon1" ? "opponent-side" : "player-side"
        );
        const statusBadge = document.getElementById(`${elPrefix}-status`);
        if (!fill || !hpText || !sideContainer || !statusBadge) return;
        const currentHp = Math.max(0, pokemon.hp);
        const percent = (currentHp / pokemon.maxHp) * 100;
        fill.style.width = percent + "%";
        if (percent < 20) fill.style.backgroundColor = "var(--danger-color)";
        else if (percent < 50)
          fill.style.backgroundColor = "var(--warning-color)";
        else fill.style.backgroundColor = "var(--success-color)";
        hpText.textContent = `${currentHp} / ${pokemon.maxHp} HP`;
        statusBadge.className = "status-badge hidden";
        if (pokemon.status && STATUS_EFFECTS[pokemon.status]) {
          const statusInfo = STATUS_EFFECTS[pokemon.status];
          statusBadge.textContent = statusInfo.badgeText;
          statusBadge.classList.add(statusInfo.cssClass);
          statusBadge.classList.remove("hidden");
        }
        if (pokemon.isFainted) {
          sideContainer.classList.add("fainted");
          sideContainer.classList.remove("active");
          statusBadge.classList.add("hidden");
        } else {
          sideContainer.classList.remove("fainted");
        }
      }
      async function playFaintAnimation(pokemonId) {
        /* ... unchanged ... */
        const sideContainer = document.getElementById(
          pokemonId === "pokemon1" ? "opponent-side" : "player-side"
        );
        if (sideContainer) {
          sideContainer.classList.add("fainted");
          sideContainer.classList.remove("active");
          await delay(ANIMATION_DELAY.FAINT);
        }
      }
      function animateAttack(attackerElId, defenderElId, moveType) {
        /* ... unchanged ... */
        const battlefield = document.querySelector(".battlefield");
        const attackerAvatar = document.getElementById(attackerElId);
        const defenderAvatar = document.getElementById(defenderElId);
        if (!attackerAvatar || !defenderAvatar || !battlefield) return;
        const attackerSide = attackerAvatar.closest(".side");
        const defenderSide = defenderAvatar.closest(".side");
        const attRect = attackerAvatar.getBoundingClientRect();
        const defRect = defenderAvatar.getBoundingClientRect();
        const bfRect = battlefield.getBoundingClientRect();
        const icon = document.createElement("div");
        icon.className = "attack-icon";
        icon.textContent = ATTACK_ICONS[moveType] || ATTACK_ICONS["Status"];
        battlefield.appendChild(icon);
        const startX = attRect.left + attRect.width / 2 - bfRect.left;
        const startY = attRect.top + attRect.height / 2 - bfRect.top;
        icon.style.left = `${startX}px`;
        icon.style.top = `${startY}px`;
        icon.style.transform = "translate(-50%, -50%) scale(0.6)";
        icon.style.opacity = "1";
        const endX = defRect.left + defRect.width / 2 - bfRect.left;
        const endY = defRect.top + defRect.height / 2 - bfRect.top;
        requestAnimationFrame(() => {
          icon.style.transform = `translate(${
            endX - startX - icon.offsetWidth / 2
          }px, ${endY - startY - icon.offsetHeight / 2}px) scale(1)`;
          icon.style.opacity = "0";
        });
        if (defenderSide) {
          defenderSide.classList.add("hit");
          setTimeout(
            () => defenderSide.classList.remove("hit"),
            ANIMATION_DELAY.SHORT
          );
        }
        setTimeout(() => icon.remove(), ANIMATION_DELAY.ATTACK_ICON);
      }
      function showStatChangeIndicator(sideId, isIncrease) {
        /* ... unchanged ... */
        const sideElement = document.getElementById(sideId);
        const infoElement = sideElement?.querySelector(".info");
        if (!infoElement) return;
        const existingIndicator = infoElement.querySelector(
          ".stat-change-indicator"
        );
        if (existingIndicator) existingIndicator.remove();
        const indicator = document.createElement("div");
        indicator.className = `stat-change-indicator ${
          isIncrease ? "stat-up" : "stat-down"
        }`;
        indicator.textContent = isIncrease ? "‚ñ≤" : "‚ñº";
        infoElement.appendChild(indicator);
        setTimeout(() => indicator.remove(), ANIMATION_DELAY.STAT_CHANGE);
      }
      function triggerScreenShake() {
        /* ... unchanged ... */
        const battlefield = document.getElementById("battlefield");
        battlefield.classList.add("shake");
        setTimeout(() => battlefield.classList.remove("shake"), 300);
      }
      function updatePlayerControls(pokemon) {
        /* ... unchanged ... */
        const controlsContainer = document.getElementById("player-controls");
        controlsContainer.innerHTML = "";
        if (
          BATTLE_STATE.gameOver ||
          !BATTLE_STATE.isPlayerTurn ||
          BATTLE_STATE.waitingForPlayer
        ) {
          controlsContainer.classList.add("hidden");
          return;
        }
        const usableMoves = pokemon.moves.filter((m) => m.currentPP > 0);
        const movesToDisplay =
          usableMoves.length > 0
            ? usableMoves
            : [{ ...MOVES.Struggle, currentPP: Infinity }];
        movesToDisplay.forEach((move) => {
          const button = document.createElement("button");
          button.classList.add("move-button");
          button.dataset.type = move.type;
          button.dataset.category = move.category;
          const currentPPLabel =
            move.pp === Infinity || move.isStruggle ? "--" : move.currentPP;
          const maxPPLabel =
            move.pp === Infinity || move.isStruggle ? "--" : move.pp;
          button.innerHTML = `${move.name}<span class="move-pp">${currentPPLabel} / ${maxPPLabel} PP</span>`;
          button.disabled = move.currentPP <= 0 && !move.isStruggle;
          button.onclick = () => {
            if (
              BATTLE_STATE.waitingForPlayer &&
              BATTLE_STATE.playerMoveResolver &&
              !button.disabled &&
              !BATTLE_STATE.isProcessing
            ) {
              BATTLE_STATE.waitingForPlayer = false;
              controlsContainer.classList.add("hidden");
              const chosenMove =
                pokemon.moves.find((m) => m.name === move.name) ||
                MOVES.Struggle;
              BATTLE_STATE.playerMoveResolver(chosenMove);
            }
          };
          controlsContainer.appendChild(button);
        });
        controlsContainer.classList.remove("hidden");
        BATTLE_STATE.waitingForPlayer = true;
        log("Choose your move!", "player-prompt");
      }

      // ********* MODULE: AI LOGIC **************
      function chooseOpponentMove(attacker, defender) {
        /* ... unchanged ... */
        const usableMoves = attacker.moves.filter((m) => m.currentPP > 0);
        if (usableMoves.length === 0) return MOVES.Struggle;
        let potentialMoves = [];
        usableMoves.forEach((move) => {
          let score = 0;
          const moveEffect = move.effect || {};
          let isViable = true;
          if (move.category !== "Status") {
            const effectiveness = calculateTypeEffectiveness(
              move.type,
              defender.types
            );
            if (effectiveness === 0) isViable = false;
          } else if (move.category === "Status") {
            if (moveEffect.type?.includes("apply_status")) {
              const status = moveEffect.status;
              if (defender.status) isViable = false;
              if (status === "BRN" && defender.types.includes("Fire"))
                isViable = false;
              if (
                status === "PSN" &&
                (defender.types.includes("Poison") ||
                  defender.types.includes("Steel"))
              )
                isViable = false;
              if (status === "PAR" && defender.types.includes("Electric"))
                isViable = false;
              if (status === "FRZ" && defender.types.includes("Ice"))
                isViable = false;
              if (move.type === "Electric" && defender.types.includes("Ground"))
                isViable = false;
              if (
                defender.types.includes("Grass") &&
                move.name === "Sleep Powder"
              )
                isViable = false;
            } else if (moveEffect.type === "lower_stat") {
              if (defender.statStages[moveEffect.stat] <= -6) isViable = false;
            } else if (moveEffect.type === "raise_stat") {
              if (attacker.statStages[moveEffect.stat] >= 6) isViable = false;
            } else if (moveEffect.type === "heal_percent") {
              if (attacker.hp >= attacker.maxHp) isViable = false;
            }
          }
          if (!isViable) {
            potentialMoves.push({ move, score: -100 + Math.random() });
            return;
          }
          if (move.category === "Physical" || move.category === "Special") {
            const { damage, effectiveness } = calculateDamage(
              attacker,
              move,
              defender
            );
            score = (move.power || 10) * effectiveness;
            if (effectiveness > 1) score *= 1.8;
            if (effectiveness < 1) score *= 0.4;
            const estimatedDamageHigh = damage * (1 / 0.85);
            if (defender.hp > 0 && defender.hp <= estimatedDamageHigh)
              score *= 3;
          } else if (move.category === "Status") {
            if (moveEffect.type?.includes("apply_status")) {
              score = 45;
              if (moveEffect.status === "SLP" || moveEffect.status === "FRZ")
                score += 15;
            } else if (moveEffect.type === "lower_stat") {
              score = 30 + Math.abs(moveEffect.stages * 10);
              if (defender.statStages[moveEffect.stat] < -2) score *= 0.5;
            } else if (moveEffect.type === "raise_stat") {
              score = 25 + moveEffect.stages * 10;
              if (
                moveEffect.stat === "atk" ||
                moveEffect.stat === "spa" ||
                moveEffect.stat === "spe"
              )
                score += 15;
              if (attacker.statStages[moveEffect.stat] > 2) score *= 0.5;
            } else if (moveEffect.type === "heal_percent") {
              score = 55 + (1 - attacker.hp / attacker.maxHp) * 50;
              if (attacker.hp > attacker.maxHp * 0.7) score *= 0.3;
            }
          }
          if (move.accuracy < 1 && move.accuracy !== null)
            score *= 0.7 + move.accuracy * 0.3;
          score += Math.random() * 5;
          potentialMoves.push({ move, score });
        });
        const viableMoves = potentialMoves.filter((pm) => pm.score > -50);
        if (viableMoves.length > 0) {
          viableMoves.sort((a, b) => b.score - a.score);
          return viableMoves[0].move;
        } else if (potentialMoves.length > 0) {
          potentialMoves.sort((a, b) => b.score - a.score);
          return potentialMoves[0].move;
        } else {
          return MOVES.Struggle;
        }
      }

      // ********* MODULE: TURN & BATTLE FLOW **************
      async function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      async function handleStatusEffectsAtTurnStart(pokemon, pokemonId) {
        /* ... unchanged ... */
        if (pokemon.isFainted || !pokemon.status) return { canMove: true };
        const status = pokemon.status;
        let canMove = true;
        let message = "";
        let clearedStatus = false;
        if (status === "PAR") {
          message = `${pokemon.name} is paralyzed!`;
          if (Math.random() < PARALYSIS_CHANCE) {
            message += ` It may be unable to move!`;
            log(message);
            await delay(ANIMATION_DELAY.STATUS_EFFECT / 2);
            log(`It couldn't move!`);
            canMove = false;
            message = "";
          }
        } else if (status === "SLP") {
          if (pokemon.statusCounter > 0) {
            message = `${pokemon.name} is fast asleep...`;
            pokemon.statusCounter--;
            canMove = false;
          } else {
            message = `${pokemon.name} woke up!`;
            pokemon.clearStatus();
            clearedStatus = true;
            updateHPDisplay(pokemon, pokemonId);
            message = "";
          }
        } else if (status === "FRZ") {
          message = `${pokemon.name} is frozen solid!`;
          if (Math.random() < THAW_CHANCE) {
            message = `${pokemon.name} thawed out!`;
            pokemon.clearStatus();
            clearedStatus = true;
            updateHPDisplay(pokemon, pokemonId);
            message = "";
          } else {
            canMove = false;
          }
        }
        if (message) {
          log(message, clearedStatus ? "status-change" : "");
          await delay(ANIMATION_DELAY.STATUS_EFFECT);
        }
        return { canMove };
      }
      async function handleStatusEffectsAtTurnEnd(pokemon, pokemonId) {
        /* ... unchanged ... */
        if (pokemon.isFainted || !pokemon.status)
          return { faintedFromStatus: false };
        const status = pokemon.status;
        let faintedFromStatus = false;
        let statusDamage = 0;
        let message = "";
        if (status === "BRN") {
          statusDamage = Math.max(1, Math.floor(pokemon.maxHp / 16));
          message = `${pokemon.name} was hurt by its burn!`;
        } else if (status === "PSN") {
          statusDamage = Math.max(1, Math.floor(pokemon.maxHp / 8));
          message = `${pokemon.name} was hurt by poison!`;
        }
        if (statusDamage > 0) {
          log(message, "status-change");
          await delay(ANIMATION_DELAY.STATUS_EFFECT / 2);
          pokemon.hp -= statusDamage;
          updateHPDisplay(pokemon, pokemonId);
          triggerScreenShake();
          await delay(ANIMATION_DELAY.HP_BAR + ANIMATION_DELAY.SHORT);
          if (pokemon.hp <= 0) {
            log(`<b>${pokemon.name} fainted!</b>`);
            pokemon.isFainted = true;
            faintedFromStatus = true;
            await playFaintAnimation(pokemonId);
          }
        }
        return { faintedFromStatus };
      }
      async function executeMove(
        attacker,
        defender,
        move,
        attackerId,
        defenderId
      ) {
        /* ... unchanged ... */
        const attackerAvatarElId = attackerId + "-avatar";
        const defenderAvatarElId = defenderId + "-avatar";
        log(
          `<b>${attacker.name}</b> used <b>${move.name}</b>!`,
          attackerId === "pokemon2" ? "player-choice" : "opponent-choice"
        );
        if (move.pp !== Infinity && !move.isStruggle) {
          const moveInSet = attacker.moves.find((m) => m.name === move.name);
          if (moveInSet) moveInSet.currentPP--;
        }
        await delay(ANIMATION_DELAY.MEDIUM);
        let hitTarget = calculateAccuracy(attacker, move, defender);
        if (!hitTarget) {
          log(`${attacker.name}'s attack missed!`);
          await delay(ANIMATION_DELAY.SHORT);
          return { fainted: false };
        }
        let isImmune = false;
        let immuneMessage = `It doesn't affect ${defender.name}...`;
        if (move.category !== "Status") {
          const effectiveness = calculateTypeEffectiveness(
            move.type,
            defender.types,
            move.ignoresTypeImmunity
          );
          if (effectiveness === 0) isImmune = true;
        } else {
          const moveEffect = move.effect || {};
          if (moveEffect.type?.includes("apply_status")) {
            const statusToApply = moveEffect.status;
            if (defender.status) {
              isImmune = true;
              immuneMessage = `${defender.name} is already afflicted with a status condition!`;
            } else if (
              statusToApply === "BRN" &&
              defender.types.includes("Fire")
            )
              isImmune = true;
            else if (
              statusToApply === "PSN" &&
              (defender.types.includes("Poison") ||
                defender.types.includes("Steel"))
            )
              isImmune = true;
            else if (
              statusToApply === "PAR" &&
              defender.types.includes("Electric")
            )
              isImmune = true;
            else if (statusToApply === "FRZ" && defender.types.includes("Ice"))
              isImmune = true;
            else if (
              move.type === "Electric" &&
              defender.types.includes("Ground")
            )
              isImmune = true;
            else if (
              defender.types.includes("Grass") &&
              move.name === "Sleep Powder"
            )
              isImmune = true;
          }
        }
        if (isImmune) {
          log(immuneMessage, "immune");
          await delay(ANIMATION_DELAY.SHORT);
          return { fainted: false };
        }
        let defenderFaintedThisTurn = false;
        let attackerFaintedThisTurn = false;
        animateAttack(
          attackerAvatarElId,
          defenderAvatarElId,
          move.type || move.category
        );
        await delay(ANIMATION_DELAY.SHORT);
        if (move.category === "Physical" || move.category === "Special") {
          const { damage, effectiveness, crit, recoilDamage } = calculateDamage(
            attacker,
            move,
            defender
          );
          if (damage > 0) {
            defender.hp -= damage;
            updateHPDisplay(defender, defenderId);
            if (crit) triggerScreenShake();
            await delay(ANIMATION_DELAY.HP_BAR);
            if (crit) {
              log("‚ú® <b>Critical Hit!</b> ‚ú®", "critical");
              await delay(ANIMATION_DELAY.SHORT);
            }
            if (effectiveness > 1)
              log("It's super effective!", "effectiveness");
            else if (effectiveness < 1)
              log("It's not very effective...", "effectiveness");
            await delay(ANIMATION_DELAY.SHORT);
            if (defender.hp <= 0) {
              log(`<b>${defender.name} fainted!</b>`);
              defender.isFainted = true;
              defenderFaintedThisTurn = true;
              await playFaintAnimation(defenderId);
              return { fainted: true };
            }
            if (!defenderFaintedThisTurn && recoilDamage > 0) {
              log(`${attacker.name} took recoil damage!`);
              attacker.hp -= recoilDamage;
              updateHPDisplay(attacker, attackerId);
              triggerScreenShake();
              await delay(ANIMATION_DELAY.HP_BAR + ANIMATION_DELAY.SHORT);
              if (attacker.hp <= 0) {
                log(`<b>${attacker.name} fainted from recoil!</b>`);
                attacker.isFainted = true;
                attackerFaintedThisTurn = true;
                await playFaintAnimation(attackerId);
                return { fainted: true };
              }
            }
          } else {
            log("The attack had no effect.");
            await delay(ANIMATION_DELAY.SHORT);
          }
        }
        if (
          !defenderFaintedThisTurn &&
          !attackerFaintedThisTurn &&
          move.effect
        ) {
          const effect = move.effect;
          let effectApplied = false;
          let targetPokemon = null;
          let targetId = null;
          if (effect.target === "self") {
            targetPokemon = attacker;
            targetId = attackerId;
          } else if (effect.target === "opponent") {
            targetPokemon = defender;
            targetId = defenderId;
          }
          if (targetPokemon) {
            const meetsChance = !effect.chance || Math.random() < effect.chance;
            if (
              (effect.type === "apply_status" ||
                effect.type === "apply_status_chance") &&
              meetsChance
            ) {
              effectApplied = targetPokemon.applyStatus(
                effect.status,
                attacker
              );
              if (effectApplied) updateHPDisplay(targetPokemon, targetId);
            } else if (
              (effect.type === "lower_stat" ||
                effect.type === "raise_stat" ||
                effect.type === "lower_stat_chance" ||
                effect.type === "raise_stat_chance") &&
              meetsChance
            ) {
              const currentStage = targetPokemon.statStages[effect.stat];
              const potentialNewStage = currentStage + effect.stages;
              if (potentialNewStage >= -6 && potentialNewStage <= 6)
                effectApplied = targetPokemon.changeStatStage(
                  effect.stat,
                  effect.stages
                );
              else if (meetsChance)
                log(
                  `${
                    targetPokemon.name
                  }'s ${effect.stat.toUpperCase()} won't go any ${
                    effect.stages > 0 ? "higher" : "lower"
                  }!`,
                  "stat-change"
                );
            } else if (effect.type === "heal_percent") {
              effectApplied = targetPokemon.heal(effect.amount);
              if (effectApplied) updateHPDisplay(targetPokemon, targetId);
            }
            if (effectApplied) await delay(ANIMATION_DELAY.STAT_CHANGE);
            else if (effect.chance && meetsChance && !effectApplied)
              await delay(ANIMATION_DELAY.SHORT);
          }
        }
        return { fainted: defenderFaintedThisTurn || attackerFaintedThisTurn };
      }
      async function executeTurn(
        attacker,
        defender,
        attackerId,
        defenderId,
        chosenMove
      ) {
        /* ... unchanged ... */
        if (attacker.isFainted || defender.isFainted || BATTLE_STATE.gameOver)
          return { battleEnded: BATTLE_STATE.gameOver };
        const defenderSide = document.getElementById(
          defenderId === "pokemon1" ? "opponent-side" : "player-side"
        );
        defenderSide?.classList.remove("active");
        BATTLE_STATE.isProcessing = true;
        const { canMove } = await handleStatusEffectsAtTurnStart(
          attacker,
          attackerId
        );
        if (!canMove) {
          const { faintedFromStatus } = await handleStatusEffectsAtTurnEnd(
            attacker,
            attackerId
          );
          BATTLE_STATE.isProcessing = false;
          return { battleEnded: faintedFromStatus || BATTLE_STATE.gameOver };
        }
        const attackerSide = document.getElementById(
          attackerId === "pokemon1" ? "opponent-side" : "player-side"
        );
        attackerSide?.classList.add("active");
        const { fainted: moveCausedFaint } = await executeMove(
          attacker,
          defender,
          chosenMove,
          attackerId,
          defenderId
        );
        if (moveCausedFaint) {
          attackerSide?.classList.remove("active");
          BATTLE_STATE.gameOver = attacker.isFainted || defender.isFainted;
          BATTLE_STATE.isProcessing = false;
          return { battleEnded: BATTLE_STATE.gameOver };
        }
        if (!attacker.isFainted) {
          const { faintedFromStatus } = await handleStatusEffectsAtTurnEnd(
            attacker,
            attackerId
          );
          if (faintedFromStatus) {
            attackerSide?.classList.remove("active");
            BATTLE_STATE.gameOver = true;
            BATTLE_STATE.isProcessing = false;
            return { battleEnded: true };
          }
        }
        BATTLE_STATE.isProcessing = false;
        return { battleEnded: BATTLE_STATE.gameOver };
      }
      async function startBattle(playerPokemonData, opponentPokemonData) {
        /* ... mostly unchanged, ensure sequential UI setup with awaits ... */
        if (BATTLE_STATE.isProcessing) return;
        BATTLE_STATE.isProcessing = true;
        BATTLE_STATE.gameOver = false;
        BATTLE_STATE.waitingForPlayer = false;
        BATTLE_STATE.isPlayerTurn = false;
        BATTLE_STATE.turnCounter = 0;
        BATTLE_STATE.battleLog = [];
        const consoleEl = document.getElementById("console");
        consoleEl.innerHTML = "";
        document.getElementById("player-controls").classList.add("hidden");
        document.getElementById("player-controls").innerHTML = "";
        document.getElementById("restart-button").classList.add("hidden");
        document
          .getElementById("opponent-side")
          ?.classList.remove("active", "fainted");
        document
          .getElementById("player-side")
          ?.classList.remove("active", "fainted");
        log(`‚ú® New Battle Starting! ‚ú®`);
        BATTLE_STATE.playerPokemon = clonePokemon(playerPokemonData);
        BATTLE_STATE.opponentPokemon = clonePokemon(opponentPokemonData);
        log(`Opponent sent out <b>${BATTLE_STATE.opponentPokemon.name}</b>!`);
        await delay(ANIMATION_DELAY.SHORT);
        log(`Go! <b>${BATTLE_STATE.playerPokemon.name}</b>!`);
        await delay(ANIMATION_DELAY.SHORT);

        function setupPokemonUI(pokemon, prefix) {
          // Inner function now needs await inside
          return new Promise(async (resolve) => {
            const avatarContainerEl = document.getElementById(
              `${prefix}-avatar-container`
            );
            const avatarEl = document.getElementById(`${prefix}-avatar`);
            const nameEl = document.getElementById(`${prefix}-name`);
            const levelEl = document.getElementById(`${prefix}-level`);
            const sideEl = document.getElementById(
              prefix === "pokemon1" ? "opponent-side" : "player-side"
            );
            if (
              !avatarContainerEl ||
              !avatarEl ||
              !nameEl ||
              !levelEl ||
              !sideEl
            ) {
              console.error("UI Element missing:", prefix);
              resolve();
              return;
            }
            sideEl.classList.remove("fainted", "active", "hit");
            avatarContainerEl.classList.remove("enter");
            avatarEl.innerHTML = "";
            avatarEl.classList.add("placeholder");
            nameEl.textContent = pokemon.name;
            levelEl.textContent = `Lv. ${pokemon.level}`;
            updateHPDisplay(pokemon, prefix);
            if (pokemon.sprite) {
              const img = document.createElement("img");
              img.alt = pokemon.name;
              img.style.opacity = "0";
              img.onload = () => {
                avatarEl.classList.remove("placeholder");
                avatarEl.appendChild(img);
                if (prefix === "pokemon2") img.style.transform = "scaleX(-1)";
                void avatarContainerEl.offsetWidth;
                avatarContainerEl.classList.add("enter");
                setTimeout(() => {
                  img.style.opacity = "1";
                }, 150);
                setTimeout(resolve, ANIMATION_DELAY.ENTRY); // Resolve after entry animation
              };
              img.onerror = () => {
                console.error("Failed sprite load:", pokemon.sprite);
                void avatarContainerEl.offsetWidth;
                avatarContainerEl.classList.add("enter");
                setTimeout(resolve, ANIMATION_DELAY.ENTRY);
              };
              img.src = pokemon.sprite;
            } else {
              void avatarContainerEl.offsetWidth;
              avatarContainerEl.classList.add("enter");
              setTimeout(resolve, ANIMATION_DELAY.ENTRY);
            }
          });
        }
        await setupPokemonUI(BATTLE_STATE.opponentPokemon, "pokemon1"); // Await completion
        await setupPokemonUI(BATTLE_STATE.playerPokemon, "pokemon2"); // Await completion

        BATTLE_STATE.isProcessing = false;

        while (
          !BATTLE_STATE.playerPokemon.isFainted &&
          !BATTLE_STATE.opponentPokemon.isFainted &&
          !BATTLE_STATE.gameOver
        ) {
          if (BATTLE_STATE.isProcessing) {
            await delay(50);
            continue;
          }
          BATTLE_STATE.turnCounter++;
          log(`--- Turn ${BATTLE_STATE.turnCounter} ---`, "turn-divider");
          await delay(ANIMATION_DELAY.SHORT);
          BATTLE_STATE.isPlayerTurn = true;
          const playerMovePromise = new Promise((resolve) => {
            BATTLE_STATE.playerMoveResolver = resolve;
            const usablePlayerMoves = BATTLE_STATE.playerPokemon.moves.filter(
              (m) => m.currentPP > 0
            );
            if (
              usablePlayerMoves.length === 0 &&
              BATTLE_STATE.playerPokemon.hp > 0
            ) {
              log(`Player has no moves with PP left! Using <b>Struggle</b>.`);
              setTimeout(() => resolve(MOVES.Struggle), ANIMATION_DELAY.SHORT);
            } else {
              updatePlayerControls(BATTLE_STATE.playerPokemon);
            }
          });
          const playerChosenMove = await playerMovePromise;
          BATTLE_STATE.isPlayerTurn = false;
          BATTLE_STATE.waitingForPlayer = false;
          BATTLE_STATE.playerMoveResolver = null;
          const opponentChosenMove = chooseOpponentMove(
            BATTLE_STATE.opponentPokemon,
            BATTLE_STATE.playerPokemon
          );
          let firstAttacker,
            secondAttacker,
            firstDefender,
            secondDefender,
            firstAttackerId,
            secondAttackerId,
            firstDefenderId,
            secondDefenderId,
            firstMove,
            secondMove;
          const p1Priority = opponentChosenMove.priority || 0;
          const p2Priority = playerChosenMove.priority || 0;
          let p1GoesFirst;
          if (p1Priority > p2Priority) p1GoesFirst = true;
          else if (p2Priority > p1Priority) p1GoesFirst = false;
          else {
            const p1Speed = BATTLE_STATE.opponentPokemon.getModifiedStat("spe");
            const p2Speed = BATTLE_STATE.playerPokemon.getModifiedStat("spe");
            if (p1Speed > p2Speed) p1GoesFirst = true;
            else if (p2Speed > p1Speed) p1GoesFirst = false;
            else p1GoesFirst = Math.random() < 0.5;
          }
          if (p1GoesFirst) {
            [firstAttacker, firstDefender] = [
              BATTLE_STATE.opponentPokemon,
              BATTLE_STATE.playerPokemon,
            ];
            [secondAttacker, secondDefender] = [
              BATTLE_STATE.playerPokemon,
              BATTLE_STATE.opponentPokemon,
            ];
            [firstAttackerId, firstDefenderId] = ["pokemon1", "pokemon2"];
            [secondAttackerId, secondDefenderId] = ["pokemon2", "pokemon1"];
            [firstMove, secondMove] = [opponentChosenMove, playerChosenMove];
          } else {
            [firstAttacker, firstDefender] = [
              BATTLE_STATE.playerPokemon,
              BATTLE_STATE.opponentPokemon,
            ];
            [secondAttacker, secondDefender] = [
              BATTLE_STATE.opponentPokemon,
              BATTLE_STATE.playerPokemon,
            ];
            [firstAttackerId, firstDefenderId] = ["pokemon2", "pokemon1"];
            [secondAttackerId, secondDefenderId] = ["pokemon1", "pokemon2"];
            [firstMove, secondMove] = [playerChosenMove, opponentChosenMove];
          }
          let turnResult = await executeTurn(
            firstAttacker,
            firstDefender,
            firstAttackerId,
            firstDefenderId,
            firstMove
          );
          if (turnResult.battleEnded) break;
          await delay(ANIMATION_DELAY.TURN_TRANSITION);
          if (secondAttacker.isFainted || firstDefender.isFainted) {
            BATTLE_STATE.gameOver = true;
            break;
          }
          turnResult = await executeTurn(
            secondAttacker,
            secondDefender,
            secondAttackerId,
            secondDefenderId,
            secondMove
          );
          if (turnResult.battleEnded) break;
          if (
            BATTLE_STATE.playerPokemon.isFainted ||
            BATTLE_STATE.opponentPokemon.isFainted
          ) {
            BATTLE_STATE.gameOver = true;
            break;
          }
          await delay(ANIMATION_DELAY.TURN_TRANSITION);
        }
        BATTLE_STATE.gameOver = true;
        BATTLE_STATE.isPlayerTurn = false;
        BATTLE_STATE.isProcessing = false;
        document.getElementById("player-controls").classList.add("hidden");
        document.getElementById("opponent-side")?.classList.remove("active");
        document.getElementById("player-side")?.classList.remove("active");
        const playerFainted = BATTLE_STATE.playerPokemon.isFainted;
        const opponentFainted = BATTLE_STATE.opponentPokemon.isFainted;
        let winnerMessage = "The battle ended in a draw?";
        if (playerFainted && !opponentFainted)
          winnerMessage = `üò≠ You lost! <b>${BATTLE_STATE.opponentPokemon.name}</b> wins the battle! üò≠`;
        else if (opponentFainted && !playerFainted)
          winnerMessage = `‚ú®üéâ <b>You Win!</b> ${BATTLE_STATE.playerPokemon.name} was victorious! üéâ‚ú®`;
        else if (playerFainted && opponentFainted)
          winnerMessage = "üí• It's a Double Knockout! The battle is a draw! üí•";
        log(`--------------------`, "turn-divider");
        log(winnerMessage, "game-over");
        document.getElementById("restart-button").classList.remove("hidden");
      }

      // ********* MODULE: INITIALIZATION & BUBBLE POP **************

      /** Gets animation duration from CSS Custom Property or uses fallback. */
      function getCssVariableDuration(propertyName, fallbackMs) {
        try {
          const durationStr = getComputedStyle(document.documentElement)
            .getPropertyValue(propertyName)
            .trim();
          if (durationStr) {
            const match = durationStr.match(/^(\d*\.?\d+)(m?s)?$/i);
            if (match) {
              const value = parseFloat(match[1]);
              const unit = match[2]?.toLowerCase();
              if (unit === "s") return value * 1000;
              if (unit === "ms" || !unit) return value;
            }
          }
        } catch (e) {
          console.warn(`Could not parse ${propertyName}:`, e);
        }
        return fallbackMs;
      }

      /** Handles the 'Pop Bubble' button click. */
      function handlePopBubble() {
        const bubbleWrapper = document.getElementById("bubble-wrapper");
        if (!bubbleWrapper) return;

        const animationDuration = getCssVariableDuration(
          "--bubble-pop-duration",
          400
        );
        const prefersReducedMotion = window.matchMedia(
          "(prefers-reduced-motion: reduce)"
        ).matches;
        const destination = "index.html"; // Assume index is in the same directory

        if (prefersReducedMotion) {
          window.location.href = destination;
        } else {
          bubbleWrapper.classList.add("popping-out");
          setTimeout(() => {
            window.location.href = destination;
          }, animationDuration);
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        const restartButton = document.getElementById("restart-button");
        const popBubbleButton = document.getElementById("pop-bubble-button");

        const initiateBattle = () => {
          /* ... initiateBattle function remains the same ... */
          if (BATTLE_STATE.isProcessing && !BATTLE_STATE.gameOver) {
            console.log("Battle already in progress, cannot restart yet.");
            return;
          }
          const pokemonKeys = Object.keys(POKEMON_DATA);
          if (pokemonKeys.length < 2) {
            console.error("Not enough Pok√©mon data!");
            log("Error: Not enough Pok√©mon defined.", "danger-color");
            return;
          }
          let playerIndex = Math.floor(Math.random() * pokemonKeys.length);
          let opponentIndex;
          do {
            opponentIndex = Math.floor(Math.random() * pokemonKeys.length);
          } while (opponentIndex === playerIndex);
          const playerPokemon = POKEMON_DATA[pokemonKeys[playerIndex]];
          const opponentPokemon = POKEMON_DATA[pokemonKeys[opponentIndex]];
          startBattle(playerPokemon, opponentPokemon).catch((error) => {
            console.error("Battle failed:", error);
            log("A critical error occurred.", "danger-color");
            BATTLE_STATE.isProcessing = false;
            document
              .getElementById("restart-button")
              .classList.remove("hidden");
          });
        };

        restartButton.addEventListener("click", initiateBattle);
        popBubbleButton.addEventListener("click", handlePopBubble); // Add listener for pop button

        setTimeout(initiateBattle, 100); // Start first battle
      });
    </script>
  </body>
</html>
